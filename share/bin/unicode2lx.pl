#!/usr/bin/perl -w

#
# Copyright 2008-2017 Katherine Flavel
#
# See LICENCE for the full copyright terms.
#

use strict;
use warnings;

use v5.24; # At least Unicode 8.0.
use v5.16; # For better fc() semantics.

use File::Spec;
use Getopt::Long;
use Time::Hires qw[];

my $CURRENT_UNICODE_MAX = 0x2_FFFF;  # As of Unicode 9.0.

# Skip the surrogates 0xD800...0xDFFF.
my @CURRENT_UNICODE_RANGE = (0x0..0xD7FF, 0xE000...$CURRENT_UNICODE_MAX);

my %Opt = ( tmpdir => '/tmp' );

sub usage {
    die <<__EOU__
$0: Usage:
  $0 --create=[foldcase|categories|scripts]
  $0 --list=[foldcase|categories|scripts]
  $0 --tmpdir=somewhere (default: $Opt{tmpdir})
  $0 --help

The --create creates the requested files in lx format in the --tmpdir.
The --list tells how large the results would be.

__EOU__
}

GetOptions("create=s" => \$Opt{create},
	   "list=s" => \$Opt{list},
	   "tmpdir=s" => \$Opt{tmpdir},
           "help")
    or usage();

my $t0 = Time::HiRes::time();

# Avoid warnings of wide character output when we print UTF-8.
binmode(STDOUT, ":utf8");
binmode(STDERR, ":utf8");

use Unicode::UCD;
my $unicode_version = Unicode::UCD::UnicodeVersion();

if (defined $Opt{create}) {
    usage() if defined $Opt{list};
    if ($Opt{create} eq 'foldcase') {
	create_foldcase();
    } elsif ($Opt{create} eq 'categories') {
	create_categories();
    } elsif ($Opt{create} eq 'scripts') {
	create_scripts();
    } else {
	usage();
    }
} elsif (defined $Opt{list}) {
    usage() if defined $Opt{create}; # Paranoia.
    if ($Opt{list} eq 'foldcase') {
	list_foldcase();
    } elsif ($Opt{list} eq 'categories') {
	list_categories();
    } elsif ($Opt{list} eq 'scripts') {
	list_scripts();
    } else {
	usage();
    }
} else {
    usage();
}

sub compute_foldcase {
    # Mapping from foldcase (the Unicode-recommended "better lowercase")
    # strings to all the single-codepoint strings that fold to the foldcase
    # string, conceptually for example: "a" => [ "a, "A" ].
    my %fc2eqset;

    # TODO: could possibly use Unicode::UCD::all_casefolds().

    for my $cp (@CURRENT_UNICODE_RANGE) {
	my $ch = pack("U", $cp);  # chr($cp) does wrong thing in 0x80..0xFF.
	next unless $ch =~ /^\pL/;

	my $fc = fc($ch);

	next if $fc eq $ch;

	my @c = ( $ch, $fc, uc($fc), lc($fc) );
	for my $p (@c) {
	    for my $q (@c) {
		$fc2eqset{$fc}{$q}++;
	    }
	}
    }

    return \%fc2eqset;
}

sub output_banner {
    my ($name) = @_;
    print <<__EOF__;
#
# $name
#
# GENERATED CODE, DO NOT EDIT!
#
# Generated by $0
#
# Perl version $^V Unicode version v$unicode_version
#

__EOF__

}

sub get_time_spent {
    return Time::HiRes::time() - $t0;
}

sub create_output {
    my ($name) = @_;
    my $fn = File::Spec->catfile($Opt{tmpdir}, "$name.lx");
    open(my $fh, ">", $fn)
	or die qq[$0: Failed to create "$fn": $!];
    print STDERR "$0: Created $fn\n";
    binmode($fh, ":utf8");
    select($fh);
    return $fh;
}

sub output_edge {
    my ($u, $v, $comment) = @_;
    # Escape the quotes.
    if ($u =~ /[\x00-\x1F\x7F\'\"]/) {
	# Escape C0, DEL, and single and double quotes.
	$u =~ s/([\x00-\x1F\x7F\'\"])/sprintf("\\x%02X", ord($1))/eg;
	$u = qq["$u"];
    } else {
	$u = qq['$u'];
    }
    printf(qq[%s -> %s;%s\n], $u, $v, defined $comment ? " # $comment" : "");
}

sub create_foldcase {
    create_output("foldcase");
    output_banner("Unicode foldcase equivalence sets");

    my $fc2eqset = compute_foldcase();

    my %fc2keys;
    for my $k0 (keys %$fc2eqset) {
	my @k1 = sort keys %{ $fc2eqset->{$k0} };
	my $k1 = "@k1";
	unless (exists $fc2keys{$k1}) {
	    $fc2keys{$k1} = [ @k1 ];
	}
    }

    my @fc2keys = sort keys %fc2keys;

    my $edges = 0;
    my $setidx = 0;
    for my $fc (@fc2keys) {
	my %combinations;
	for my $k (@{ $fc2keys{$fc}}) {
	    # We want in @iterators an array of array references, one inner
	    # aref for each Unicode codepoint in the fold-cased string.
	    # For example for "ffl" we want to have:
	    # [ [ 'f', 'F' ], [ 'f', 'F' ], [ 'l', 'L' ] ]
	    my @iterators;
	    for my $cp (split(//, $k)) {
		push @iterators,
	        [ exists $fc2eqset->{$cp} ? keys %{ $fc2eqset->{$cp} } : $cp ];
	    }
	    # What we want to do is to generate all the possible combinations
	    # of these alternatives, from the above example a total of eight,
	    # from 'ffl' to 'FFL'.  We do this by iterating through the
	    # iterators, and at each round appending the current value
	    # of the iterator to the current set of strings.  For example:
	    # [ '' ] -> [ 'f', 'F' ] -> [ 'ff', 'fF', 'Ff', 'FF' ] ->
	    # [ 'ffl', 'fFl', 'Ffl', 'FFl', 'ffL', 'fFL', 'FfL', 'FFL' ]
	    my %more = ( '' => 1  );
	    for my $i1 (@iterators) {
		my @more = keys %more;
		my %next;
		for my $i2 (@$i1) {
		    for my $next (@more) {
			$next{ $next . $i2 }++;
		    }
		}
		%more = %next;
	    }
	    @combinations{keys %more} = values %more;
	}
	my @combinations = sort keys %combinations;
	print "# \$u$setidx: @combinations\n\n";
	for my $combinations (@combinations) {
	    output_edge($combinations, "\$u${setidx}");
	    $edges++;
	}
	print "\n";
	$setidx++;
    }

    my $dt = get_time_spent();

    printf(STDERR "$0: Generated %d edges to %d sets in %.3fs\n",
	   $edges, $setidx, $dt);
}

sub create_categories {
    print STDERR "$0: create_categories: this will be slow\n";
    use Unicode::UCD 'charinfo';
    my %output;
    my %catid;
    my $catid = 0;
    my $edges = 0;
    for my $cp (@CURRENT_UNICODE_RANGE) {
	my $ch = pack('U', $cp);
	my $ci = charinfo($cp);
	my $cat = $ci->{category};
	if (defined $cat) {
	    for my $c (substr($cat, 0, 1), $cat) {
		if (defined $output{$c}) {
		    select($output{$c});
		} else {
		    $output{$c} = create_output($c);
		    $catid{$c} = $catid++;
		    output_banner("Unicode General Category: $c");
		}
		output_edge($ch, "\$u$catid{$c}", sprintf("U+%04X", $cp));
		$edges++;
	    }
	}
    }
    my $dt = get_time_spent();
    printf(STDERR "$0: Generated %d edges for %d categories in %.3fs\n",
	   $edges, $catid, $dt);
    select(STDOUT);
}

sub create_scripts {
    use Unicode::UCD 'charscripts';
    my $charscripts = charscripts();
    my $i = 0;
    my $edges = 0;
    my $scripts = 0;
    for my $k (sort keys %$charscripts) {
	create_output($k);
	output_banner("Unicode Script: $k");
	for my $r (@{$charscripts->{$k}}) {
	    for my $cp ($r->[0]..$r->[1]) {
		my $ch = pack('U', $cp);
		output_edge($ch, "\$u$i", sprintf("U+%04X", $cp));
		$edges++;
	    }
	}
	select(STDOUT);
	$scripts++;
    }
    my $dt = get_time_spent();
    printf(STDERR "$0: Generated %d edges for %d scripts in %.3fs\n",
	   $edges, $scripts, $dt);
}

sub list_foldcase {
    my $fc2eqset = compute_foldcase();
    printf "foldcase %d\n", scalar keys %$fc2eqset;
}

sub list_categories {
    print STDERR "$0: list_categories: this will be slow\n";
    use Unicode::UCD 'charinfo';
    my %categories;
    for my $cp (0x0..$CURRENT_UNICODE_MAX) {
	my $ci = charinfo($cp);
	my $cat = $ci->{category};
	if (defined $cat) {
	    $categories{$cat}++;
	    $categories{substr($cat, 0, 1)}++;
	}
    }
    for my $cat (sort keys %categories) {
	print "$cat $categories{$cat}\n";
    }
}

sub list_scripts {
    use Unicode::UCD 'charscripts';
    my $scripts = charscripts();
    for my $k (sort keys %$scripts) {
	my $n = 0;
	for my $r (@{$scripts->{$k}}) {
	    $n += $r->[1] - $r->[0] + 1;
	}
	print "$k $n\n";
    }
}

exit(0);
