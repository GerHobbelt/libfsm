<?xml version="1.0"?>
<!DOCTYPE refentry SYSTEM "minidocbook.dtd" [

	<!-- TODO: centralise to mdb -->
	<!ENTITY stdin.lit  "<literal>stdin</literal>">
	<!ENTITY stdout.lit "<literal>stdout</literal>">

	<!-- TODO: centralise to mdb -->
	<!ENTITY re.arg   "<replaceable>re</replaceable>">
	<!ENTITY file.arg "<replaceable>file</replaceable>">

	<!ENTITY c.opt "<option>-c</option>">
	<!ENTITY i.opt "<option>-i</option>">
	<!ENTITY d.opt "<option>-d</option>">
	<!ENTITY m.opt "<option>-m</option>">
	<!ENTITY n.opt "<option>-n</option>">

	<!ENTITY dialect-file.opt "<option>-lgebp9es</option>&nbsp;&file.arg;">
	<!ENTITY dialect-re.opt   "<option>-lgebp9es</option>&nbsp;&re.arg;">

	<!ENTITY h.opt "<option>-h</option>">
	<!ENTITY v.opt "<option>-v</option>">

]>

<refentry>
	<refentryinfo>
		<productname>re</productname>
	</refentryinfo>

	<refmeta>
		<refentrytitle>re</refentrytitle>
		<manvolnum>1</manvolnum>
	</refmeta>

	<refnamediv>
		<refname>re</refname>
		<refpurpose>Construct Finite State Machines from Regular Expressions</refpurpose>
	</refnamediv>

	<refsynopsisdiv>
<!--
+fprintf(stderr, "usage: re -d { [-cidmn] [-lgeb9ps] <re> }\n");
+fprintf(stderr, "usage: re -e { [-cidmn] [-lgeb9ps] <re> }\n");
+fprintf(stderr, "usage: re    { [-cidmn] [-lgeb9ps] <re> } <string>\n");
TODO: re-do usage()
TODO: other than -h, three modes; exec (default), dump, example
-->

		<cmdsynopsis>
			<command>re</command>

			<arg choice="opt">&c.opt;</arg>
			<arg choice="opt">&d.opt;</arg>
			<arg choice="opt">&m.opt;</arg>
			<arg choice="opt">&n.opt;</arg>
			<arg choice="opt">&i.opt;</arg>

			<!-- TODO: rep here doesn't seem to work -->
			<arg choice="plain" repeat="rep">&dialect-re.opt;</arg>

			<arg choice="plain" rep="repeat">&str.arg;</arg>
		</cmdsynopsis>

		<cmdsynopsis>
			<command>re</command>

			<group choice="req">
				<arg choice="plain">&h.opt;</arg>
<!-- TODO: does re(1) have -v?
				<arg choice="plain">&v.opt;</arg>
-->
			</group>
		</cmdsynopsis>
	</refsynopsisdiv>

	<refsection>
		<title>Description</title>

		<para>The &re.1; tool constructs a Finite State Machine
			from Regular Expression syntax.
			The &fsm; is constructed by joining &nfa; fragments,
			which may be preserved by the &n.opt; option.
			The constructed &fsm; may be output in &fsm.5; format,
			e.g. to be manipulated by &fsm.1;.</para>

		<para>The regular expression can be &ldquo;executed&rdquo;
			to match against strings,
			or used to provide example strings which would match.
			Unlike &grep.1;, strings are matched from
			command line arguments rather than &stdin.lit;.</para>
<!-- TODO: can't we feed a string to stdin, too? -->
<!-- TODO: -i for files rather than patterns -->

<!--
                for (i = 0; i < argc; i++) {
                        r += !fsm_exec(fsm, fsm_sgetc, &argv[i]);
                }
-->

		<para>This tool provides an interface to the &re.3; &api;.</para>
	</refsection>

	<refsection>
		<title>Options</title>

		<variablelist>
			<varlistentry>
				<term>&c.opt;</term>

				<listitem>
					<para>When multiple regular expressions are specified,
						&c.opt; joins them by concatenation.
						The default is to join by union.
						See &fsm_concat.3; and &fsm_union.3; respectively.</para>
				</listitem>
			</varlistentry>

			<varlistentry>
				<term>&d.opt;</term>

				<listitem>
					<para>TODO: Dump FSM to &stdout.lit;.
						The FSM is written out in &fsm.5; format.</para>
<!-- TODO: doesn't stop executing?
        if (dump) {
                fsm_print(fsm, stdout, FSM_OUT_FSM, NULL);
        }
-->
				</listitem>
			</varlistentry>

			<varlistentry>
				<term>&i.opt;</term>

				<listitem>
					<para>The &i.opt; option specifies that instead of
						regular expressions given as strings on the command line,
						regular expressions are given by files instead.
						These are of the form &dialect-file.opt;,
						where a given file contains a regular expression
						in the respective dialect.</para>
<!-- TODO: each file could contain a list of regexps -->
				</listitem>
			</varlistentry>

			<varlistentry>
				<term>&m.opt;</term>

				<listitem>
					<para>Print an example string which would be matched by the
						constructed &fsm;.
						Examples strings are generated by &fsm_example.3;,
						and are intended to be short and legible.
						Long examples are trunacted, which is indicated by
						a trailing <literal>...</literal>.</para>
				</listitem>
			</varlistentry>

			<varlistentry>
				<term>&n.opt;</term>

				<listitem>
					<para>TODO: keep NFA</para>
<!-- TOOD:
if (keep_nfa && argc > 0) {
fprintf(stderr, "-n is not for execution; execution requires a DFA\n");
TODO: could execute by thompson's NFA instead
-->
				</listitem>
			</varlistentry>

			<varlistentry>
				<term>&dialect-re.opt;</term>

				<listitem>
					<para>TODO: </para>

					<para>This option may be specified multiple times,
						and the regular expressions will be joined together
						(see the &c.opt; option).</para>


					<para>Dialects are:</para>

					<table>
						<col align="left"/>
						<col align="left"/>

						<thead>
							<tr>
								<th>Option</th>
								<th>Symbol</th>
								<th>Specification</th>
								<th>Name</th>
							</tr>
						</thead>

						<tbody>
							<tr>
								<td><option>-e</option></td>
								<td><code>RE_ERE</code></td>
								<td>&posix; &re_format.7;</td>
								<td>&posix; Extended Regular Expression</td>
							</tr>
							<tr>
								<td><option>-b</option></td>
								<td><code>RE_BRE</code></td>
								<td>&posix; &re_format.7;</td>
								<td>&posix; Basic Regular Expression</td>
							</tr>
							<tr>
								<td><option>-9</option></td>
								<td><code>RE_PLAN9</code></td>
								<td>Plan 9 &regexp.7;</td>
								<td>Plan 9 Regular Expression</td>
							</tr>
							<tr>
								<td><option>-p</option></td>
								<td><code>RE_PCRE</code></td>
								<td>&pcre.3;</td>
								<td>Perl Compatible Regular Expressions</td>
							</tr>
							<tr>
								<td><option>-l</option></td>
								<td><code>RE_LITERAL</code></td>
								<td>&literal.5re;</td>
								<td>Literal strings</td>
							</tr>
							<tr>
								<td><option>-g</option></td>
								<td><code>RE_GLOB</code></td>
								<td>&glob.5re;</td>
								<td>Glob patterns</td>
							</tr>
							<tr>
								<td><option>-s</option></td>
								<td><code>RE_NATIVE</code></td>
								<td>&native.5re;</td>
								<td>&re.3; &ldquo;Native&rdquo; syntax</td>
							</tr>
						</tbody>
					</table>
				</listitem>
			</varlistentry>

<!-- TODO:

			<varlistentry>
				<term>&v.opt;</term>

				<listitem>
					<para>Causes &re.1; to print its version number.</para>
				</listitem>
			</varlistentry>
-->

			<varlistentry>
				<term>&h.opt;</term>

				<listitem>
					<para>Causes &re.1; to print command-line usage help.</para>
				</listitem>
			</varlistentry>
		</variablelist>
	</refsection>

	<refsection>
		<title>See Also</title>

		<para>&fsm.1;, &grep.1;, &fsm.3;, &re.3;,
			&pcre.3;,
			&fsm_concat.3;, &fsm_union.3;,
			&literal.5re;, &glob.5re;, &native.5re;,
			&posix; &re_format.7;, Plan 9 &regexp.7;.</para>
	</refsection>
</refentry>

