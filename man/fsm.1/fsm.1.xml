<?xml version="1.0"?>
<!DOCTYPE refentry SYSTEM "minidocbook.dtd" [

	<!-- TODO: centralise to mdb -->
	<!ENTITY stdin.lit  "<literal>stdin</literal>">
	<!ENTITY stdout.lit "<literal>stdout</literal>">

	<!-- TODO: centralise to mdb -->
	<!ENTITY prefix.arg "<replaceable>prefix</replaceable>">

	<!ENTITY a.opt "<option>-a</option>">
	<!ENTITY c.opt "<option>-c</option>">
	<!ENTITY d.opt "<option>-d</option>">
	<!ENTITY e.opt "<option>-e</option>&nbsp;&str.arg;">
	<!ENTITY g.opt "<option>-g</option>">
	<!ENTITY l.opt "<option>-l</option>&nbsp;&lang.arg;">
	<!ENTITY m.opt "<option>-m</option>">
	<!ENTITY n.opt "<option>-n</option>&nbsp;&prefix.arg;">
	<!ENTITY o.opt "<option>-o</option>&nbsp;&out-file.arg;">
	<!ENTITY p.opt "<option>-p</option>">
	<!ENTITY q.opt "<option>-q</option>&nbsp;&name.arg;">
	<!ENTITY r.opt "<option>-r</option>">
	<!ENTITY t.opt "<option>-t</option>&nbsp;&name.arg;">
	<!ENTITY P.opt "<option>-P</option>">


	<!ENTITY h.opt "<option>-h</option>">
	<!ENTITY v.opt "<option>-v</option>">

	<!ENTITY c.lit    "<literal>c</literal>">
	<!ENTITY csv.lit  "<literal>csv</literal>">
	<!ENTITY dot.lit  "<literal>dot</literal>">
	<!ENTITY fsm.lit  "<literal>fsm</literal>">
	<!ENTITY json.lit "<literal>json</literal>">
]>

<refentry>
	<refentryinfo>
		<productname>fsm</productname>
	</refentryinfo>

	<refmeta>
		<refentrytitle>fsm</refentrytitle>
		<manvolnum>1</manvolnum>
	</refmeta>

	<refnamediv>
		<refname>fsm</refname>
		<refpurpose>Define and manipulate Finite State Machines</refpurpose>
	</refnamediv>

	<refsynopsisdiv>
		<cmdsynopsis>
			<command>fsm</command>

			<arg choice="opt">&a.opt;</arg>
			<arg choice="opt">&c.opt;</arg>
			<arg choice="opt">&d.opt;</arg>
			<arg choice="opt">&g.opt;</arg>
			<arg choice="opt">&l.opt;</arg>
			<arg choice="opt">&m.opt;</arg>
			<arg choice="opt">&n.opt;</arg>
			<arg choice="opt">&o.opt;</arg>

			<sbr/>

			<arg choice="opt">&p.opt;</arg>
			<arg choice="opt">&q.opt;</arg>
			<arg choice="opt">&r.opt;</arg>
			<arg choice="opt">&t.opt;</arg>

			<arg choice="opt">&P.opt;</arg>

			<group choice="opt">
				<arg choice="plain">&e.opt;</arg>
				<arg choice="plain">&q.opt;</arg>
			</group>
		</cmdsynopsis>

		<cmdsynopsis>
			<command>fsm</command>

			<group choice="req">
				<arg choice="plain">&h.opt;</arg>
				<arg choice="plain">&v.opt;</arg>
			</group>
		</cmdsynopsis>
	</refsynopsisdiv>

	<refsection>
		<title>Description</title>

		<para>&fsm.1; is a command line tool to define and manipulate
			Finite State Machines.
			It exposes the functionality provided by the &fsm.3; &api;.</para>

		<para>Finite State Machines are defined using the &fsm.5; syntax,
			which is read from &stdin.lit;.
			Output is written to &stdout.lit; unless otherwise specified.</para>
	</refsection>

	<refsection>
		<title>Options</title>

		<variablelist>
			<varlistentry>
				<term>&a.opt;</term>

				<listitem>
					<para>When producing Graphviz output (by <code>-l&nbsp;dot</code>),
						draw states anonymously.</para>

					<para>The default is to label each state with a unique
						identifier.</para>
				</listitem>
			</varlistentry>

			<varlistentry>
				<term>&c.opt;</term>

				<listitem>
					<para>When producing Graphviz output (by <code>-l&nbsp;dot</code>),
						draw multiple similar transitions by the same edge.
						These consolidated edges are labelled to indicate the
						set of transitions they represent.
						This is an aesthetic optimisation for sake of producing
						more legible diagrams.</para>

					<para>The default is to draw each transition as a separate edge.</para>
				</listitem>
			</varlistentry>

			<varlistentry>
				<term>&d.opt;</term>

				<listitem>
					<para>Equivalent to <code>-t&nbsp;determinise</code>.</para>
				</listitem>
			</varlistentry>

			<varlistentry>
<!-- -e <execution> -->
				<term>&e.opt;</term>

				<listitem>
					<para>
			case 'e': exec
					</para>
				</listitem>
			</varlistentry>

			<varlistentry>
				<term>&g.opt;</term>

				<listitem>
					<para>
			case 'g': out_options.fragment          = 1;      break;
					</para>
				</listitem>
			</varlistentry>

			<varlistentry>
				<term>&l.opt;</term>

				<listitem>
					<para>
			case 'l': format = language(optarg);     break;
					</para>
TODO: language

<!-- [-l <language>] -->
<!-- -l language: -->

					<table>
						<col align="left"/>
						<col align="left"/>
						<col align="left"/>

						<thead>
							<tr>
								<th>Language</th>
								<th>Extension</th>
								<th>Description</th>
							</tr>
						</thead>

						<tbody>
							<tr>
								<td>&c.lit;</td>
								<td>&c.ext;</td>
<!-- TODO: ISO C90, or &ansi; -->
								<td>Generated parser in TODO standard C.</td>
							</tr>
							<tr>
								<td>&csv.lit;</td>
								<td>&csv.ext;</td>
								<td>TODO</td>
							</tr>
							<tr>
								<td>&dot.lit;</td>
								<td>&dot.ext;</td>
								<td>TODO</td>
							</tr>
							<tr>
								<td>&fsm.lit;</td>
								<td>&fsm.ext;</td>
								<td>TODO</td>
							</tr>
							<tr>
								<td>&json.lit;</td>
								<td>&json.ext;</td>
								<td>TODO</td>
							</tr>
<!-- TODO
							<tr>
								<td>&test.lit;</td>
								<td role="na" align="center">&ndash;</td>
								<td>For testing TODO</td>
							</tr>
-->
						</tbody>
					</table>

					<para>The default is &c.lit;.</para>

				</listitem>
			</varlistentry>

			<varlistentry>
				<term>&m.opt;</term>

				<listitem>
					<para>Equivalent to <code>-t&nbsp;minimise</code>.</para> <!-- TODO: markup -->
				</listitem>
			</varlistentry>

			<varlistentry>
<!-- [-n <prefix>] -->
				<term>&n.opt;</term>

				<listitem>
					<para>
			case 'n': out_options.prefix            = optarg; break;
					</para>
				</listitem>
			</varlistentry>

			<varlistentry>
<!-- [-o <file> ] -->
				<term>&o.opt;</term>

				<listitem>
					<para>
			case 'o': out = 0 == strcmp(optarg, "-") ? stdout : fopen(optarg, "w");
					</para>
				</listitem>
			</varlistentry>

			<varlistentry>
				<term>&p.opt;</term>

				<listitem>
					<para>
			case 'p': out = stdout;
equivalent to <code>-o&nbsp;-</code>
					</para>
				</listitem>
			</varlistentry>

			<varlistentry>
<!-- -q <query> -->
				<term>&q.opt;</term>

				<listitem>
					<para>
			case 'q': exit(query(fsm, optarg));      break;
					</para>

<!-- TODO: some of these are not implemented -->
					<table>
						<col align="left"/>
						<col align="left"/>
						<col align="left"/>

						<thead>
							<tr>
								<th>Name</th>
								<th>&api;</th>
								<th>Description</th>
							</tr>
						</thead>

						<tbody>
							<tr>
								<td><code>isdfa</code></td>
								<td rowspan="2">&fsm_isdfa.3;</td>
								<td rowspan="2">True if the &fsm;
									is &deterministic.term;.</td>
							</tr>
							<tr>
								<td><code>dfa</code></td>
							</tr>
							<tr>
								<td><code>iscomplete</code></td>
								<td>&fsm_iscomplete.3;</td>
								<td>True if the &fsm; is &complete.term;.</td>
							</tr>
							<tr>
								<td><code>hasend</code></td>
								<td rowspan="4">&fsm_hasend.3;</td>
								<td rowspan="4">True if the &fsm;
									has at least one &final.term; state.</td>
							</tr>
							<tr>
								<td><code>end</code></td>
							</tr>
							<tr>
								<td><code>hasaccept</code></td>
							</tr>
							<tr>
								<td><code>accept</code></td>
							</tr>
							<!-- TODO: also final, hasfinal -->
						</tbody>
					</table>
				</listitem>
			</varlistentry>

			<varlistentry>
				<term>&r.opt;</term>

				<listitem>
					<para>Equivalent to <code>-t&nbsp;reverse</code>.</para>
				</listitem>
			</varlistentry>

			<varlistentry>
<!-- [-t <transformation>] -->
				<term>&t.opt;</term>

				<listitem>
					<para>Apply a transformation.</para>

case 't': transform(fsm, optarg);        break;

					<table>
						<col align="left"/>
						<col align="left"/>
						<col align="left"/>

						<thead>
							<tr>
								<th>Name</th>
								<th>&api;</th>
								<th>Description</th>
							</tr>
						</thead>

						<tbody>
							<tr>
<!-- TODO: not implemented -->
								<td><code>complete</code></td>
								<td>&fsm_complete.3;</td>
								<td>Make the &fsm; &complete.term;.</td>
<!-- TODO: explain if the FSM is already one of these, no-op -->
							</tr>
							<tr>
								<td><code>complement</code></td>
								<td rowspan="2">&fsm_complement.3;</td>
								<td rowspan="2">&complement.term; the &fsm;.</td>
<!-- TODO: explain doing this twice gives you the same thing -->
							</tr>
							<tr>
								<td><code>invert</code></td>
							</tr>
							<tr>
								<td><code>reverse</code></td>
								<td rowspan="2">&fsm_reverse.3;</td>
								<td rowspan="2">&reverse.term; the &fsm;.</td>
<!-- TODO: explain doing this twice gives you the same thing -->
							</tr>
							<tr>
								<td><code>rev</code></td>
							</tr>
							<tr>
								<td><code>determinise</code></td>
								<td rowspan="2">&fsm_determinise.3;</td>
								<td rowspan="2">Make the &fsm; &deterministic.term;.
									That is, transform it to a &dfa;.</td>
<!-- TODO: explain if the FSM is already one of these, no-op -->
							</tr>
							<tr>
								<td><code>dfa</code></td>
							</tr>
							<tr>
								<td><code>minimise</code></td>
								<td rowspan="2">&fsm_minimise.3;</td>
								<td rowspan="2">Make the &fsm; &minimal.term;.
									That is, transform it to a canonical state-minimal &dfa;.</td>
<!-- TODO: explain if the FSM is already one of these, no-op -->
							</tr>
							<tr>
								<td><code>min</code></td>
							</tr>
						</tbody>
					</table>
				</listitem>
			</varlistentry>

			<varlistentry>
				<term>&P.opt;</term>
<!-- [-P <file>] -->

				<listitem>
					<para>
				FILE *f;
				f = 0 == strcmp(optarg, "-") ? stdout : fopen(optarg, "w");
					</para>
				</listitem>
			</varlistentry>

			<varlistentry>
				<term>&v.opt;</term>

				<listitem>
					<para>Causes &fsm.1; to print its version number.</para>
				</listitem>
			</varlistentry>

			<varlistentry>
				<term>&h.opt;</term>

				<listitem>
					<para>Causes &fsm.1; to print command-line usage help.</para>
				</listitem>
			</varlistentry>
		</variablelist>
	</refsection>

	<refsection>
		<title>See Also</title>

		<para>&re.1;, &fsm.3;.</para>
	</refsection>
</refentry>

