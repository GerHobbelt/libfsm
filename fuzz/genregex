#!/usr/bin/awk -f

function usage() {
	print("genregex <seed> <dialect> <max_terms> <max_class> <max_m> <max_n> <labels>\n");
	exit(1)
}

function shift_arg(name) {
	shift_arg_offset++
	if (ARGV[shift_arg_offset] == "-h") { usage(); }
	return (ARGC > shift_arg_offset ? ARGV[shift_arg_offset] : def[name])
}

function randint(x) {
	return int(rand() * x)
}

function populate(prob, d) {
	n = 0;
	for (f in prob) {
		for (i = 0; i < prob[f]; i++) {
			d[n] = f;
			n++;
		}
	}
}

function dispatch(d) {
	count = length(d)
	k = randint(count)
	f = d[k];
	@f();
}

# start is 1-based
function print_char(labels, start) {
	count = length(labels) - start - 1
	li = start + randint(count)
	printf("%c", substr(labels, li, 1));
	return li;
}

# min is 0-based
function print_hex(min) {
	c = min + randint(256 - min);
	printf("\\x%02x", c);
	return c;
}

function atom_char() {
	print_char(labels, 1);
}

function atom_hex() {
	print_hex(0);
}

function atom_special() {
	s = "nrtvf\\";
	count = length(s)
	li = randint(count)
	lbl = substr(s, li, 1)
	printf("\\%s", lbl);
}

function atom_class() {
	printf("[");

	if (rand() < prob_not) {
		printf("^");
	}

	num_class = randint(max_class)

	# XXX: should be legal
	if (num_class == 0) {
		num_class = 1;
	}

	for (tx = 0; tx < num_class; tx++) {
		dispatch(d_class);
	}

	printf("]");
}

function atom_group() {
	printf("(");
	print_term();
	printf(")");
}

function atom_ncgroup() {
	printf("(?:");
	print_term();
	printf(")");
}

function op_cat() {
	printf("");
}

function op_qmark() {
	printf("?");
}

function op_plus() {
	printf("+");
}

function op_star() {
	printf("*");
}

function op_m() {
	printf("{%u}", randint(max_m));
}

function op_mx() {
# TODO:	printf("{%u,}", randint(max_m));
}

function op_mn() {
	printf("{%u,%u}", randint(max_m), max_m + randint(max_n - max_m));
}

function class_range() {
	min = print_char(labels, 1);
	printf("-");
	print_char(labels, min);
}

function class_hexrange() {
	min = print_hex(0);
	printf("-");
	print_hex(min);
}

function print_term() {
	num_terms--; # fewer terms for deeper nesting

	if (rand() < prob_alt) {
		print_term();
		printf("|");
		print_term();
		return;
	}

	dispatch(d_atom);
	dispatch(d_op);

	num_terms++;
}

BEGIN {
	def["seed"]      = 210881
	def["dialect"]   = "native"
	def["max_terms"] = 50
	def["max_class"] = 5
	def["max_m"]     = 5
	def["max_n"]     = 10
	def["labels"]    = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
	# TODO: full characterset 0..UCHAR_MAX for labels; escape special characters

	seed      = shift_arg("seed") + 0
	dialect   = shift_arg("dialect") ""
	max_terms = shift_arg("max_terms") + 0
	max_class = shift_arg("max_class") + 0
	max_m     = shift_arg("max_m") + 0
	max_n     = shift_arg("max_n") + 0
	labels    = shift_arg("labels") ""

	# XXX: make configurable
	prob_alt = 0.2;
	prob_not = 0.3;

	if (max_n < max_m) {
		max_n = max_n;
	}

	srand(seed);

	# relative probabilities
	# TODO: override from argv
	# TODO: different dialects would set some of these to 0

	prob_atom["atom_char"]    = 3;
	prob_atom["atom_hex"]     = 1;
	prob_atom["atom_special"] = 1;
	prob_atom["atom_class"]   = 1;
	prob_atom["atom_group"]   = 1;
	prob_atom["atom_ncgroup"] = 1;

	prob_op["op_cat"]   = 2;
	prob_op["op_qmark"] = 1;
	prob_op["op_plus"]  = 1;
	prob_op["op_star"]  = 1;
	prob_op["op_m"]     = 1;
	prob_op["op_mx"]    = 1;
	prob_op["op_mn"]    = 1;

	prob_class["atom_char"]      = 2;
	prob_class["atom_hex"]       = 1;
	prob_class["atom_special"]   = 1;
	prob_class["class_range"]    = 1;
	prob_class["class_hexrange"] = 1;

	if (dialect == "literal") {
		prob_alt = 0;

		delete prob_atom["atom_hex"];
		delete prob_atom["atom_special"];
		delete prob_atom["atom_class"];
		delete prob_atom["atom_group"];
		delete prob_atom["atom_ncgroup"];

		delete prob_op["op_qmark"];
		delete prob_op["op_plus"];
		delete prob_op["op_star"];
		delete prob_op["op_m"];
		delete prob_op["op_mx"];
		delete prob_op["op_mn"];
	} else if (dialect == "native") {
		delete prob_atom["atom_ncgroup"];
	} else if (dialect == "pcre") {
		# nothing to disable
	} else {
		printf("unsupported dialect: %s\n", dialect);
		exit(2);
	}

	populate(prob_atom, d_atom);
	populate(prob_op, d_op);
	populate(prob_class, d_class);

	num_terms = randint(max_terms)
	if (num_terms == 0 && max_terms >= 1 && rand() > 0.1) {
		num_terms = 1;
	}

	for (t = 0; t < num_terms; t++) {
		print_term();
	}
}

