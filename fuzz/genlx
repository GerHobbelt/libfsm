#!/usr/bin/awk -f

function usage() {
	print("genlx <seed> <max_things> <zone_limit>\n");
	exit(1)
}

function shift_arg(name) {
	shift_arg_offset++
	if (ARGV[shift_arg_offset] == "-h") { usage(); }
	return (ARGC > shift_arg_offset ? ARGV[shift_arg_offset] : def[name])
}

function randint(x) {
	return int(rand() * x)
}

function populate(prob, d) {
	n = 0;
	for (f in prob) {
		for (i = 0; i < prob[f]; i++) {
			d[n] = f;
			n++;
		}
	}
}

function dispatch(d) {
	count = length(d)
	k = randint(count)
	f = d[k];
	@f();
}

function print_indent(indent) {
	while (indent-- > 0) {
		printf("  ");
	}
}

function print_token() {
	printf("$")
	printf("t%u", randint(53)); # XXX
}

function print_var() {
	printf("v%u", randint(53)); # XXX
	# TODO: keep stack of variables for zone scope, use when referencing a variable
	# index by [zone, var]
}

function genregex(dialect, quote) {
	printf("%c", quote);

	system(sprintf("%s %u %s %u %u", genregex_path, randint(1000), dialect, 5, 3));
	# TODO: escape stuff appropriately

	# TODO: exclude regexps which match the empty string, invoke re(1) to test

	printf("%c", quote);
}

function pattern_single() { genregex("literal", "'");  }
function pattern_double() { genregex("literal", "\""); }
function pattern_regexp() { genregex("native",  "/");  }

function term_parens() {
	printf("(");
	print_term();
	printf(")");
}

function print_prefix(op) {
	printf("%s", op);
	print_term();
}

function print_suffix(op) {
	print_term();
	printf("%s", op);
	# XXX: can generate x++
}

function print_binop(op) {
	print_term();
	printf(" %s ", op);
	print_term();
}

function term_tilde() { print_prefix("~"); }
function term_bang()  { print_prefix("!"); }
function term_hat()   { print_prefix("^"); }

function term_qmark() { print_suffix("?"); }
function term_cross() { print_suffix("+"); }
function term_star()  { print_suffix("*"); }

function term_dash()  { print_binop("-");  }
function term_dot()   { print_binop(".");  }
function term_pipe()  { print_binop("|");  }
function term_and()   { print_binop("&");  }

function print_term()
{
	# XXX: should split grouped vs. atomic clauses
	# but !/x/? should still be possible
	dispatch(d_term);
}

function print_expr(    n) {
	print_term();

	n = randint(3) + 1; # XXX: configurable

	# TODO: recursive grammar for expressions
	while (n-- > zone * 2) { # fewer things for deeper zones
		printf(" ");
		print_term();
	}
}

function print_mapping() {
	print_expr();

	if (rand() < prob_to) {
		printf(" -> ");
		print_token();
	}
}

function print_body(zone,    n) {
	if (zone + 1 > zone_limit) {
		prob_thing["thing_zone"] = 0;
		delete d_thing;
		populate(prob_thing, d_thing);
	}

	n = randint(max_things)
	if (n == 0 && max_things >= 1 && rand() > 0.1) {
		n = 1;
	}

	# need at least one thing in a zone
	dispatch(d_thing);

	while (n-- > zone * 2) { # fewer things for deeper zones
		print_indent(zone);
		dispatch(d_thing);
	}
}

function thing_mapping() {
	print_mapping();
	print ";"
}

function thing_skip() {
	print_mapping();
	if (rand() > prob_skip) {
		printf(" .. ");
		print_mapping();
	}
	print ";"
}

function thing_zone() {
	print_mapping();
	if (rand() < prob_exit) {
		printf(" .. ");
		print_mapping();
	}
	print " {"
	print_body(++zone);
	print_indent(--zone);
	print "}"
}

function thing_bind() {
	print_var();
	printf(" = ");
	print_expr();
	print ";"
}

function thing_special() {
	s = "nrtvf\\";
	count = length(s)
	li = randint(count)
	lbl = substr(s, li, 1)
	printf("\\%s", lbl);
}

function thing_group() {
	dispatch(d_op);

	printf("(");
	print_thing();
	printf(")");
}

function thing_ncgroup() {
	printf("(?:");
	print_thing();
	printf(")");
}

BEGIN {
	def["seed"]       = 210881
	def["max_things"] = 20
	def["zone_limit"] = 50

	seed       = shift_arg("seed") + 0
	max_things = shift_arg("max_things") + 0
	zone_limit = shift_arg("zone_limit") + 0

	prob_to   = 0.8; # XXX: make configurable
	prob_skip = 0.5; # XXX: make configurable
	prob_exit = 0.9; # XXX: make configurable

# TODO: find from argv
	genregex_path = "./genregex";

	srand(seed);

	prob_thing["thing_mapping"] = 4;
	prob_thing["thing_skip"]    = 2;
	prob_thing["thing_zone"]    = 1;
	prob_thing["thing_bind"]    = 2;

	prob_term["pattern_single"] = 5;
	prob_term["pattern_double"] = 5;
	prob_term["pattern_regexp"] = 8;

	prob_term["term_parens"] = 2;
	prob_term["term_star"]   = 2;
	prob_term["term_cross"]  = 2;
	prob_term["term_qmark"]  = 2;

	# prefix
	prob_term["term_tilde"]  = 2;
	prob_term["term_bang"]   = 2;
	prob_term["term_hat"]    = 2;

	# binary
	prob_term["term_dash"]   = 1;
#	prob_term["term_dot"]    = 0; # XXX: unimplemented
	prob_term["term_pipe"]   = 1;
	prob_term["term_and"]    = 1;

	populate(prob_thing, d_thing);
	populate(prob_term, d_term);

	printf("# seed = %u\n", seed);
	printf("# max_things = %u\n", max_things);
	printf("# zone_limit = %u\n", zone_limit);
	printf("\n");

	print_body(0);
}

