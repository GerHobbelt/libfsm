/* $Id$ */

ACTION <flush>;
ACTION <push>:     (:CHARACTER) -> ();
ACTION <push_esc>: (:CHARACTER) -> ();
ACTION <flags>;

GROUP white = "\r\n\t ";

ZONE comment: "#" ... "\n" {
	GROUP white = "";
	TOKEN DEFAULT -> $$;
}

ZONE pattern_literal: "'" -> <flush> ... "'" -> $pattern_literal {
	GROUP white = "";
	TOKEN DEFAULT -> <push>(#0);
}

ZONE pattern_string: "\"" -> <flush> ... "\"" -> $pattern_literal {
	GROUP white = "";
	TOKEN "\\n"   -> <push_esc>(#1);
	TOKEN "\\t"   -> <push_esc>(#1);
	TOKEN "\\r"   -> <push_esc>(#1);
	TOKEN DEFAULT -> <push>(#0);
}

ZONE pattern_regex: "/" -> <flush> ... "/" -> <flags>, $pattern_regex {
	GROUP white = "";
	TOKEN DEFAULT -> <push>(#0);
}


TOKEN "|"  -> $alt;
TOKEN ";"  -> $semi;
TOKEN ".." -> $to;
TOKEN "->" -> $map;
TOKEN "\e" -> $eof;

TOKEN "{"  -> $open;
TOKEN "}"  -> $close;


GROUP alpha = {A-Z} + {a-z};
GROUP alnum = {0-9} + "[alpha]" + "_";
ZONE token: "$[alpha]" -> <flush>, <push>(#1) [...) "[^alnum]" -> $token_name {
	TOKEN DEFAULT -> <push>(#0);
}



/*
 * In .lx this would be something like:

/[\r\n\t ]/;
"#" .. "\n";

"'" .. "'" {
	/./  -> $pattern_literal;
}

# Here we're relying on the grammar to express strings.
# another approach would be to say: /"(.*)"/ -> $string; and have a parser action
# map down the escapes, but think from a "lexer for syntax hilighting" perspective.
'"' .. '"' {
	'\n' -> $pattern_str_n;
	'\t' -> $pattern_str_t;
	'\r' -> $pattern_str_r;
	/./  -> $pattern_literal;
}

'/' .. '/' /([gi]*)/ -> $flags {
	/./  -> $pattern_regex;
}

'|'  -> $alt;
';'  -> $semi;
'..' -> $to;
'->' -> $map;
# note EOF is dealt with automatically

'{'  -> $open;
'}'  -> $close;

'$' /([a-z][a-z0-9]+)/i -> $token;

*/

