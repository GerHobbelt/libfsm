/*
 * Copyright 2008-2017 Katherine Flavel
 *
 * See LICENCE for the full copyright terms.
 */

/*
 * ISO/IEC 9075-2:1999 (E) Â©ISO/IEC
 * 8.6 <similar predicate>
 *
 * https://firebirdsql.org/refdocs/langrefupd25-similar-to.html
 *
 * TODO: SQL99 permits an arbitrary optional escape character
 */

%types%

	pos;
	char;
	unsigned;
	!fsm;
	!fsm_state;
	!grp;
	!pred;
	!re_flags;
	!err;
	ast_expr;
	ast_count;
        ast_class_id;

%terminals%

	ANY;
	MANY;
	OPT;
	PLUS;
	ALT;
	STAR;

	OPENSUB;   CLOSESUB;
	!OPENGROUP:  () -> (:pos, :pos); !CLOSEGROUP:  () -> (:char, :pos, :pos);
	OPENCOUNT: () -> (:pos, :pos);
	COUNT: () -> (:unsigned);
	SEP;
	CLOSECOUNT: () -> (:pos, :pos);

	!INVERT: () -> (:char);
	!RANGE:  () -> (:char, :pos, :pos);

        !CLASS_alnum:   () -> (:ast_class_id);
	!CLASS_alpha:   () -> (:ast_class_id);
	!CLASS_any:    () -> (:ast_class_id);
	!CLASS_ascii:  () -> (:ast_class_id);
	!CLASS_blank:  () -> (:ast_class_id);
	!CLASS_cntrl:  () -> (:ast_class_id);
	!CLASS_digit:   () -> (:ast_class_id);
	!CLASS_graph:  () -> (:ast_class_id);
	!CLASS_lower:   () -> (:ast_class_id);
	!CLASS_print:  () -> (:ast_class_id);
	!CLASS_punct:  () -> (:ast_class_id);
	!CLASS_space:   () -> (:ast_class_id);
	!CLASS_spchr:   () -> (:ast_class_id);
	!CLASS_upper:   () -> (:ast_class_id);
	!CLASS_word:   () -> (:ast_class_id);
	!CLASS_xdigit: () -> (:ast_class_id);
	!CLASS_ndigit: () -> (:ast_class_id);
	!CLASS_nspace: () -> (:ast_class_id);

	!OPENFLAGS;
	!CLOSEFLAGS;
	!NEGATE;
	!FLAG_UNKNOWN;
	!FLAG_INSENSITIVE: () -> (:re_flags);

	!ESC:     () -> (:char, :pos, :pos);
	!CONTROL: () -> (:char, :pos, :pos);
	!NOESC:   () -> (:char, :pos, :pos);
	!OCT:     () -> (:char, :pos, :pos);
	!HEX:     () -> (:char, :pos, :pos);
	CHAR:     () -> (:char, :pos, :pos);
	!START:   () -> (:pred);
	!END:     () -> (:pred);

	EOF;
	!ERROR;

%productions%

	!<make-group>:  () -> (:grp);
	!<invert-group>:    (:grp &) -> ();
	!<group-add-char>:  (:grp &, :char) -> ();
	!<group-add-class>: (:grp &, :fsm) -> ();
	!<group-add-range>: (:grp &, :char, :char) -> ();
	!<group-to-states>: (:grp &, :fsm_state, :fsm_state) -> ();

	!<add-concat>:  () -> (:fsm_state);
	!<add-epsilon>: (:fsm_state, :fsm_state)        -> ();
	!<add-pred>:   (:fsm_state, :fsm_state, :pred) -> ();
	!<add-literal>: (:fsm_state, :fsm_state, :char) -> ();
	!<add-any>:     (:fsm_state, :fsm_state)        -> ();
	!<add-class>:  (:fsm_state, :fsm_state, :fsm)  -> ();

	!<count-m-to-n>: (:fsm_state, :fsm_state &, :unsigned, :unsigned) -> ();
	!<count-0-or-1>: (:fsm_state, :fsm_state) -> ();
	!<count-0-or-many>: (:fsm_state, :fsm_state &) -> ();
	!<count-1-or-many>: (:fsm_state, :fsm_state &) -> ();
	!<count-1>: (:fsm_state, :fsm_state) -> ();

	!<push-flags>;
	!<pop-flags>;
	!<set-flag>: (:re_flags) -> ();
	!<clear-flag>: (:re_flags) -> ();

	!<err-expected-term>;
	!<err-expected-count>;
	!<err-expected-atoms>;
	!<err-expected-alts>;
	!<err-expected-range>;
	!<err-expected-closegroup>;
	!<err-unknown-flag>;
	!<err-expected-closeflags>;
	!<err-expected-groupbody>;
	<err-expected-eof>;

	!<mark-group>: (:pos, :pos) -> ();
	!<mark-range>: (:pos, :pos) -> ();
	!<mark-count>: (:pos, :pos) -> ();

        <atom-kleene>: () -> (:ast_count);
        <atom-plus>: () -> (:ast_count);
        <atom-one>: () -> (:ast_count);
        <atom-opt>: () -> (:ast_count);

        <expr-count>: (:unsigned, :unsigned) -> (:ast_count);

	<ast-expr-empty>: () -> (:ast_expr);
	<ast-expr-literal>: (:char) -> (:ast_expr);
	<ast-expr-concat>: (:ast_expr, :ast_expr) -> (:ast_expr);
	<ast-expr-alt>: (:ast_expr, :ast_expr) -> (:ast_expr);
	!<ast-expr-any>: () -> (:ast_expr);
	!<ast-expr-many>: () -> (:ast_expr);

        <ast-expr-atom>: (:ast_expr, :ast_count) -> (:ast_expr);
        <ast-expr-atom-any>: (:ast_count) -> (:ast_expr);
        <ast-expr-atom-many>: (:ast_count) -> (:ast_expr);

	expr: () -> (n :ast_expr) [
                literal: () -> (n :ast_expr) = {
  			(c, !, !) = CHAR;
			n = <ast-expr-literal>(c);
  		};

		/* TODO: "atom{L,H}" when int(L), int(H) */
		atom-suffix: () -> (f :ast_count) = {
			STAR;
			f = <atom-kleene>();
		||
			PLUS;
			f = <atom-plus>();
		||
			OPT;
			f = <atom-opt>();
		||
			(pos_of, pos_ot) = OPENCOUNT;
			l = COUNT;
			(pos_cf, pos_ct) = CLOSECOUNT;
			f = <expr-count>(l, l);
		||
			(pos_of, pos_ot) = OPENCOUNT;
			l = COUNT;
			SEP;
			h = COUNT;
			(pos_cf, pos_ct) = CLOSECOUNT;
			f = <expr-count>(l, h);
		||
			f = <atom-one>();
		};

		/* group: () -> (n :ast_expr) = {
		 * 	OPENGROUP;
		 * 	INVERT;
		 * 	b = group-body();
		 * 	CLOSEGROUP;
		 * 	<ast-expr-group-inverted>(b);
		 * ||
		 * 	OPENGROUP;
		 * 	b = group-body();
		 * 	CLOSEGROUP;
		 * 	<ast-expr-group>(b);
  		 * };
		 * 
		 * group-body: () -> (b :group_body) = {
		 *         h = group-body-head();
		 * 
		 * 	m = list-of-terms();
		 * 
		 * 	t = group-body-tail();
		 * 
		 * 	b = <ast-expr-group-body>(h, m, t);
		 * };
		 * 
                 * list-of-terms: () ->  */

		/* TODO: is there a better name than 'atom' for
		 * this construct?
		 * maybe better to have a flag for one/kleene/plus,
		 * and give that to most other AST nodes? */
		atom: () -> (n :ast_expr) = {
			OPENSUB;
			e = expr();
			CLOSESUB;
			s = atom-suffix();
			n = <ast-expr-atom>(e, s);
		/* ||
		 * 	e = group();
		 * 	s = atom-suffix();
		 * 	n = <ast-expr-atom>(e, s); */
		||
			e = literal();
			s = atom-suffix();
			n = <ast-expr-atom>(e, s);
		||
			ANY;
			s = atom-suffix();
			n = <ast-expr-atom-any>(s);
		||
			MANY;
			s = atom-suffix();
			n = <ast-expr-atom-many>(s);
		};

		list-of-atoms: () -> (n :ast_expr) = {
			n = atom();
		||
			a = atom();
			r = list-of-atoms();
			n = <ast-expr-concat>(a,r);
		};

		alt: () -> (n :ast_expr) = {
			n = list-of-atoms();
		};

		list-of-alts: () -> (n :ast_expr) = {
			n = alt();
		||
			a = alt();
			ALT;
			r = list-of-alts();
			n = <ast-expr-alt>(a, r);
		};
	] = {
		n = list-of-alts();
	};

	re_sql: () -> (n :ast_expr) = {
		{
			n = expr();
		##
			n = <ast-expr-empty>();
		};

		{
			EOF;
		##
			<err-expected-eof>;
		};
	};

%entry%

	re_sql;

