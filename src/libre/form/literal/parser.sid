/* $Id$ */

%types%

	char;
	unsigned;
	fsm_state;
	bm;
	pred;

%terminals%

	!QMARK;
	!STAR;
	!PLUS;
	!DOT;
	!ALT;
	!SEP;

	!OPENSUB;   !CLOSESUB;
	!OPENGROUP; !CLOSEGROUP: () -> (:char);
	!OPENCOUNT; !CLOSECOUNT;

	!INVERT: () -> (:char);
	!RANGE:  () -> (:char);

	!ESC:    () -> (:char);
	!OCT:    () -> (:char);
	!HEX:    () -> (:char);
	CHAR:    () -> (:char);
	!START:  () -> (:pred);
	!END:    () -> (:pred);
	!COUNT:  () -> (:unsigned);

	EOF;
	!ERROR;

%productions%

	<make-states>: () -> (:fsm_state, :fsm_state);

	!<make-group>: () -> (:bm);
	!<free-group>: (:bm) -> ();
	!<invert-group>: (:bm) -> ();
	!<group-add-char>: (:bm, :char) -> ();
	!<group-add-range>: (:bm, :char, :char) -> ();
	!<group-to-states>: (:bm, :fsm_state, :fsm_state) -> ();

	<add-concat>:  () -> (:fsm_state);
	<add-epsilon>: (:fsm_state, :fsm_state)        -> ();
	<add-literal>: (:fsm_state, :fsm_state, :char) -> ();
	!<add-pred>:   (:fsm_state, :fsm_state, :pred) -> ();
	!<add-any>:    (:fsm_state, :fsm_state)        -> ();

	!<count-m-to-n>: (:fsm_state, :fsm_state &, :unsigned, :unsigned) -> ();
	!<count-0-or-1>: (:fsm_state, :fsm_state) -> ();
	!<count-0-or-many>: (:fsm_state, :fsm_state &) -> ();
	!<count-1-or-many>: (:fsm_state, :fsm_state &) -> ();
	<count-1>: (:fsm_state, :fsm_state) -> ();

	!<err-expected-term>;
	!<err-expected-count>;
	<err-expected-atoms>;
	!<err-expected-alts>;
	!<err-expected-range>;
	<err-expected-eof>;

	list-of-literals: (x :fsm_state, y :fsm_state) -> () [

		literal: (x :fsm_state, y :fsm_state) -> () = {
			c = CHAR;
			<add-literal>(x, y, c);
			<count-1>(x, y);
		};

	] = {
		z = <add-concat>;
		literal(x, z);

		{
			list-of-literals(z, y);
		||
			/* TODO: I don't like this. refactor somehow? */
			<add-epsilon>(z, y);
		};
	};

	re_literal: () -> () = {
		(x, y) = <make-states>;

		{
			list-of-literals(x, y);
		||
			<add-epsilon>(x, y);
		##
			<err-expected-atoms>;	/* TODO: inappropiate? */
		};

		{
			EOF;
		##
			<err-expected-eof>;
		};
	};

%entry%

	re_literal;

