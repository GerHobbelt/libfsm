/* $Id$ */

%prefixes%

	terminal = TOK_;
	function = p_;
	type     = t_;

%persistents%

	fsm       :fsm;
	cflags    :cflags;
	lex_state :lex_state;
	act_state :act_state;

%maps%

%header% @{

	#include <assert.h>
	#include <stdlib.h>
	#include <limits.h>

	#include <fsm/fsm.h>

	#include <re/re.h>

	#include "parser.h"
	#include "lexer.h"

	typedef char     t_char;
	typedef unsigned t_unsigned;
	typedef char *   t_grp;

	typedef struct fsm_state * t_fsm__state;

@}, @{

	#include "lexer.h"

	typedef struct fsm *       fsm;
	typedef enum re_cflags     cflags;
	typedef struct lex_state * lex_state;
	typedef struct act_state * act_state;

	struct act_state {
		enum lx_token lex_tok;
		enum lx_token lex_tok_save;
		enum re_err err;

		enum lx_token (*lex_next)(struct lx *);
	};

	struct lex_state {
		struct lx lx;
		struct lx_dynbuf buf; /* XXX: unneccessary since we're lexing from a string */

		int (*lgetc)(void *opaque);
		void *opaque;

		/* TODO: use lx's generated conveniences for the pattern buffer */
		char a[512];
		char *p;
	};

	#define CURRENT_TERMINAL (act_state->lex_tok)
	#define ERROR_TERMINAL   @$ERROR
	#define ADVANCE_LEXER    do { act_state->lex_tok = act_state->lex_next(&lex_state->lx); } while (0)
	#define SAVE_LEXER(tok)  do { act_state->lex_tok_save = act_state->lex_tok;  \
	                              act_state->lex_tok = tok;                      } while (0)
	#define RESTORE_LEXER    do { act_state->lex_tok = act_state->lex_tok_save;  } while (0)

@};

%terminals%

	CHAR: () -> (c :char) = @{
		assert(lex_state->buf.a[0] != '\0');
		assert(lex_state->buf.a[1] == '\0');

		@c = lex_state->buf.a[0];
	@};

	COUNT: () -> (n :unsigned) = @{
		@n = strtoul(lex_state->buf.a, NULL, 10);
		/* TODO: range check */
	@};

	EOL: () -> (c :char) = @{
		@c = 0;	/* TODO */
	@};

	SOL: () -> (c :char) = @{
		@c = 1;	/* TODO */
	@};

%actions%

	/*
	 * These are parser actions common to all grammars provided by libre.
	 * Globs use only a few of the available actions; regexps use most.
	 *
	 * In some cases (e.g. counting) actions are centralised here for
	 * the sake of DRY, at the expense of slight overkill.
	 */

	<make-states>: () -> (x :fsm_state, y :fsm_state) = @{
		assert(fsm != NULL);
		/* TODO: assert fsm is empty */

		@x = fsm_getstart(fsm);
		assert(@x != NULL);

		@y = fsm_addstate(fsm);
		if (@y == NULL) {
			@!;
		}

		fsm_setend(fsm, @y, 1);
	@};


	<make-group>: () -> (g :grp) = @{
		@g = calloc(UCHAR_MAX, sizeof *@g);
		if (@g == NULL) {
			@!;
		}
	@};

	<free-group>: (g :grp) -> () = @{
		assert(@g != NULL);

		free(@g);
	@};

	<invert-group>: (g :grp) -> () = @{
		int i;

		assert(@g != NULL);

		for (i = 0; i <= UCHAR_MAX; i++) {
			@g[i] = !@g[i];
		}
	@};

	<group-add-char>: (g :grp, c :char) -> () = @{
		assert(@g != NULL);

		@g[(unsigned char) @c] = 1;
	@};

	<group-add-range>: (g :grp, a :char, b :char) -> () = @{
		int i;

		assert(@g != NULL);

		for (i = (unsigned char) @a; i <= (unsigned char) @b; i++) {
			@g[i] = 1;
		}
	@};

	<group-to-states>: (g :grp, x :fsm_state, y :fsm_state) -> () = @{
		int i;

		assert(@g != NULL);

		/* TODO: eventually libfsm will provide a neater mechanism here */
		for (i = 0; i <= UCHAR_MAX; i++) {
			if (!@g[i]) {
				continue;
			}

			if (!fsm_addedge_literal(fsm, @x, @y, (char) i)) {
				@!;
			}
		}
	@};


	/*
	 * The following regular expression fragments map to associated fsm states
	 * as follows (transitions written in .fsm format):
	 *
	 *  ab    add-concat:  1 -> 3 "a"; 3 -> 2 "b";
	 *  a|b   add-alt:     1 -> 2 "a"; 1 -> 2 "b";
	 *  (a)   add-sub:     1 -> 1a; 2a -> 2;
	 *  [abc] add-group:   1 -> 2 "a"; 1 -> 2 "b"; 1 -> 2 "c";
	 *  a     add-literal: 1 -> 1a; 2a -> 2;
	 *  .     add-any:     1 -> 2 ?;
	 *
	 * Each of these component parts has exactly one input (1) and exactly one
	 * output state (2).
	 * TODO: say that these correspond to "x" and "y"
	 * TODO: explain that these are stacklike
	 * TODO: update these comments
	 */

	<add-concat>: () -> (s :fsm_state) = @{
		@s = fsm_addstate(fsm);
		if (@s == NULL) {
			@!;
		}
	@};

	<add-epsilon>: (x :fsm_state, y: fsm_state) -> () = @{
		if (!fsm_addedge_epsilon(fsm, @x, @y)) {
			@!;
		}
	@};

	<add-literal>: (x :fsm_state, y :fsm_state, c :char) -> () = @{
		assert(@x != NULL);
		assert(@y != NULL);

		/* TODO: check c is legal? */

		if (!fsm_addedge_literal(fsm, @x, @y, @c)) {
			@!;
		}
	@};

	<add-any>: (x :fsm_state, y :fsm_state) -> () = @{
		assert(@x != NULL);
		assert(@y != NULL);

		if (!fsm_addedge_any(fsm, @x, @y)) {
			@!;
		}
	@};


	/*
	 * The following count repetition operators encapsulate regular expression
	 * fragments as follows (transitions written in .fsm format where 1a and 2a
	 * indicate the a'th occurance of the input and output states 1 and 2 from
	 * the fragment):
	 *
	 *  a{n} count-n:         8 -> 1a; 2a -> 1b; 2b -> ...a; ...b -> na; nb -> 9;
	 *  a?   count-0-or-1:    8 -> 1a; 2a -> 9; 8 -> 9;
	 *  a*   count-0-or-many: 8 -> 1a; 2a -> 9; 8 -> 9; 9 -> 8;
	 *  a+   count-1-or-many: 8 -> 1a; 2a -> 9;         9 -> 8;
	 *  a    count-1:         8 -> 1a; 2a -> 9;
	 *
	 * Each of these component parts has exactly one input (8) and exactly one
	 * output state (9). Between these states are an appropiate number of
	 * regex fragments as per <add-*> which begin and end (1) and (2). Each of
	 * these pairs is lettered a, b, ..., n for ease of identification.
	 *
	 * TODO: update for count-m-n
	 */

	<count-m-to-n>: (x :fsm_state, y :fsm_state &, m :unsigned, n :unsigned) -> () = @{
		unsigned i;
		struct fsm_state *a;
		struct fsm_state *b;

		if (@m == 0) {
			@!;
		}

		if (@n < @m) {
			@!;
		}

		b = @y;

		for (i = 1; i < @n; i++) {
			a = fsm_state_duplicatesubgraphx(fsm, @x, &b);
			if (a == NULL) {
				@!;
			}

			/* TODO: could elide this epsilon if fsm_state_duplicatesubgraphx()
			 * took an extra parameter giving it a m->new for the start state */
			if (!fsm_addedge_epsilon(fsm, @y, a)) {
				@!;
			}

			if (i >= @m) {
				if (!fsm_addedge_epsilon(fsm, @y, b)) {
					@!;
				}
			}

			@=y = b;
			@x = a;
		}
	@};

	<count-0-or-1>: (x :fsm_state, y :fsm_state) -> () = @{
		if (!fsm_addedge_epsilon(fsm, @x, @y)) {
			@!;
		}
	@};

	<count-0-or-many>: (x :fsm_state, y :fsm_state &) -> () = @{
		if (!fsm_addedge_epsilon(fsm, @x, @y)) {
			@!;
		}

		if (!fsm_addedge_epsilon(fsm, @y, @x)) {
			@!;
		}

		/* isolation guard */
		/* TODO: centralise */
		{
			struct fsm_state *z;

			z = fsm_addstate(fsm);
			if (z == NULL) {
				@!;
			}

			if (!fsm_addedge_epsilon(fsm, @y, z)) {
				@!;
			}

			@=y = z;
		}
	@};

	<count-1-or-many>: (x :fsm_state, y :fsm_state &) -> () = @{
		if (!fsm_addedge_epsilon(fsm, @y, @x)) {
			@!;
		}

		/* isolation guard */
		/* TODO: centralise */
		{
			struct fsm_state *z;

			z = fsm_addstate(fsm);
			if (z == NULL) {
				@!;
			}

			if (!fsm_addedge_epsilon(fsm, @y, z)) {
				@!;
			}

			@=y = z;
		}
	@};

	<count-1>: (x :fsm_state, y :fsm_state) -> () = @{
		(void) @x;
		(void) @y;
	@};


	<err-expected-term> = @{
		act_state->err = RE_EXTERM;
	@};

	<err-expected-count> = @{
		act_state->err = RE_EXCOUNT;
	@};

	<err-expected-items> = @{
		act_state->err = RE_EXITEMS;
	@};

	<err-expected-alts> = @{
		act_state->err = RE_EXALTS;
	@};

	<err-expected-eof> = @{
		act_state->err = RE_EXEOF;
	@};

%trailer% @{

@}, @{

@};

