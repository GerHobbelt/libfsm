/* $Id$ */

%prefixes%

	terminal = lex_;
	function = p_;

%persistents%

	lex_state :lex_state;
	act_state :act_state;

%maps%

	string -> string;
	re     -> re;
	zone   -> zone;
	ast    -> ast;

%header% @{

	#include <assert.h>
	#include <stdio.h>
	#include <stdlib.h>

	#include <re/re.h>

	#include "lexer.h"
	#include "parser.h"
	#include "xalloc.h"
	#include "ast.h"

	typedef char *           string;
	typedef struct re *      re;
	typedef struct lx_zone * zone;

	struct act_state {
		int lex_tok;
		int lex_tok_save;
	};

	#define CURRENT_TERMINAL (act_state->lex_tok)
	#define ERROR_TERMINAL   lex_unknown
	#define ADVANCE_LEXER    do { act_state->lex_tok = lex_nexttoken(lex_state); } while (0)
	#define SAVE_LEXER(tok)  do { act_state->lex_tok_save = act_state->lex_tok; \
	                              act_state->lex_tok = tok;                      } while (0)
	#define RESTORE_LEXER    do { act_state->lex_tok = act_state->lex_tok_save;  } while (0)

	static void err_expected(const char *token) {
		fprintf(stderr, "syntax error: expected %s\n", token);
		exit(EXIT_FAILURE);
	}

@}, @{

	#include <stdio.h>

	#include "ast.h"

	typedef struct lex_state * lex_state;
	typedef struct act_state * act_state;
	typedef struct lx_ast *    ast;

	struct lx_ast *lx_parse(FILE *f);

@};

%terminals%

	pattern_regex: () -> (s :string) = @{
		@s = xstrdup(lex_tokbuf(lex_state));
		if (@s == NULL) {
			perror("xstrdup");
			exit(EXIT_FAILURE);
		}
	@};

	pattern_literal: () -> (s :string) = @{
		@s = xstrdup(lex_tokbuf(lex_state));
		if (@s == NULL) {
			perror("xstrdup");
			exit(EXIT_FAILURE);
		}
	@};

	token_name: () -> (s :string) = @{
		@s = xstrdup(lex_tokbuf(lex_state));
		if (@s == NULL) {
			perror("xstrdup");
			exit(EXIT_FAILURE);
		}
	@};

%actions%

	<compile-literal>: (s :string) -> (r :re) = @{
		assert(@s != NULL);

		@r = re_new_comp(RE_LITERAL, re_getc_str, &@s, 0, NULL, NULL);
		if (@r == NULL) {
			/* TODO: use *err */
			@!;
		}
	@};

	<compile-regex>:   (s :string) -> (r :re) = @{
		assert(@s != NULL);

		@r = re_new_comp(RE_SIMPLE, re_getc_str, &@s, 0, NULL, NULL);
		if (@r == NULL) {
			/* TODO: use *err */
			@!;
		}
	@};

	<concat-regex>: (a :re, b :re) -> (r :re) = @{
		assert(@a != NULL);
		assert(@b != NULL);

		if (!re_concat(@a, @b)) {
			perror("re_concat");
			@!;
		}

		@r = @a;
	@};

	<make-ast>: () -> (a :ast) = @{
		@a = ast_new();
		if (@a == NULL) {
			perror("ast_new");
			@!;
		}
	@};

	<make-zone>: (a :ast) -> (z :zone) = @{
		assert(@a != NULL);

		@z = ast_addzone(@a);
		if (@z == NULL) {
			perror("ast_addzone");
			@!;
		}
	@};

	<make-mapping>: (z :zone, r :re, t :string) -> () = @{
		assert(@z != NULL);
		assert(@r != NULL);

		/* TODO: "to" zone, if present */

		if (!ast_addmapping(@z, @r, @t, NULL)) {
			perror("ast_addmapping");
			@!;
		}
	@};

	<no-token>: () -> (s :string) = @{
		@s = NULL;
	@};

	<free>: (s :string) -> () = @{
		free(@s);
	@};

	<err-syntax> = @{
		fprintf(stderr, "syntax error\n");
		exit(EXIT_FAILURE);
	@};

	<err-expected-alt> = @{
		err_expected("'|'");
	@};

	<err-expected-map> = @{
		err_expected("'->'");
	@};

	<err-expected-semi> = @{
		err_expected("';'");
	@};

	<err-expected-to> = @{
		err_expected("'..'");
	@};

	<err-expected-open> = @{
		err_expected("'{'");
	@};

	<err-expected-close> = @{
		err_expected("'}'");
	@};

	<err-expected-eof> = @{
		err_expected("EOF");
	@};

	<err-expected-name> = @{
		err_expected("token name");
	@};

	<err-expected-list> = @{
		err_expected("list of token mappings or zones");
	@};

%trailer% @{

	struct lx_ast *lx_parse(FILE *f) {
		struct act_state act_state_s;
		struct act_state *act_state;
		struct lex_state *lex_state;
		struct lx_ast *ast;

		assert(f != NULL);

		lex_state = lex_init(f);
		if (lex_state == NULL) {
			perror("lex_init");
			return NULL;
		}

		/* This is a workaround for ADVANCE_LEXER assuming a pointer */
		act_state = &act_state_s;

		ADVANCE_LEXER;	/* XXX: what if the first token is unrecognised? */
		p_lx(lex_state, act_state, &ast);

		assert(ast != NULL);

		lex_free(lex_state);

		return ast;
	}

@}, @{

@};

