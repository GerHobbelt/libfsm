
/*
 * Automatically generated by lexi version 2.0
 */

#include "lexer.h"



	#include <assert.h>
	#include <stdio.h>
	#include <stdlib.h>
	#include <string.h>

	#include "parser.h"

	#define lexi_unknown_token lex_unknown

	struct lex_state {
		struct lexi_state lexi_state;
		char tokbuf[20];
		FILE *file;
	};

	static void push(struct lex_state *lex_state, int c) {
		size_t l;

		assert(lex_state != NULL);

		l = strlen(lex_state->tokbuf);
		if (l == sizeof lex_state->tokbuf) {
			fprintf(stderr, "token buffer full\n");
			exit(1);
		}

		lex_state->tokbuf[l] = c;
		lex_state->tokbuf[l + 1] = '\0';
	}

	static int lexi_getchar(struct lexi_state *state) {
		int c;

		assert(state != NULL);
		assert(state->lex_state != NULL);
		assert(state->lex_state->file != NULL);

		c = fgetc(state->lex_state->file);
		if (c == EOF) {
			return LEXI_EOF;
		}

		return c;
	}

int lexi_readchar(struct lexi_state *state) {
	if (state->buffer_index) {
		return lexi_pop(state);
	}

	return lexi_getchar(state);
}
void lexi_push(struct lexi_state *state, const int c) {
	state->buffer[state->buffer_index++] = c;
}

int lexi_pop(struct lexi_state *state) {
	return state->buffer[--state->buffer_index];
}

void lexi_flush(struct lexi_state *state) {
	state->buffer_index = 0;
}


/* LOOKUP TABLE */

typedef unsigned char lookup_type;
static lookup_type lookup_tab[] = {
	   0,    0,    0,    0,    0,    0,    0,    0,    0,  0x4,  0x4,    0, 
	   0,  0x4,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0, 
	   0,    0,    0,    0,    0,    0,    0,    0,  0x4,    0,    0,    0, 
	   0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0, 
	 0x1,  0x1,  0x1,  0x1,  0x1,  0x1,  0x1,  0x1,  0x1,  0x1,    0,    0, 
	   0,    0,    0,    0,    0,  0x3,  0x3,  0x3,  0x3,  0x3,  0x3,  0x3, 
	 0x3,  0x3,  0x3,  0x3,  0x3,  0x3,  0x3,  0x3,  0x3,  0x3,  0x3,  0x3, 
	 0x3,  0x3,  0x3,  0x3,  0x3,  0x3,  0x3,    0,    0,    0,    0,  0x1, 
	   0,  0x3,  0x3,  0x3,  0x3,  0x3,  0x3,  0x3,  0x3,  0x3,  0x3,  0x3, 
	 0x3,  0x3,  0x3,  0x3,  0x3,  0x3,  0x3,  0x3,  0x3,  0x3,  0x3,  0x3, 
	 0x3,  0x3,  0x3,    0,    0,    0,    0,    0,    0,    0,    0,    0, 
	   0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0, 
	   0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0, 
	   0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0, 
	   0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0, 
	   0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0, 
	   0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0, 
	   0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0, 
	   0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0, 
	   0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0, 
	   0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0, 
	   0,    0,    0,    0
};

int lexi_group(enum lexi_groups group, int c) {
	return lookup_tab[c] & group;
}


/* PRE-PASS ANALYSERS */

void lexi_init(struct lexi_state *state, lex_statep lex_state) {
	state->zone = lexi_read_token;
	state->buffer_index = 0;
	state->lex_state = lex_state;
}
/* ZONES PASS ANALYSER PROTOTYPES*/

static int lexi_read_token_token(struct lexi_state *state);
static int lexi_read_token_pattern_regex(struct lexi_state *state);
static int lexi_read_token_pattern_string(struct lexi_state *state);
static int lexi_read_token_pattern_literal(struct lexi_state *state);
static void lexi_read_token_comment(struct lexi_state *state);
/* MAIN PASS ANALYSERS */


/* MAIN PASS ANALYSER for token */
static int
lexi_read_token_token(struct lexi_state *state)
{
	start: {
		int c0 = lexi_readchar(state);
		if (lexi_group(lexi_group_white, c0)) goto start;
		if (!lexi_group(lexi_group_alnum, c0)) {
			lexi_push(state, c0);
			return lex_token__name;
		}

		/* DEFAULT */
		/* ACTION <push> */
		{

	push(state->lex_state, c0);
		}
		/* END ACTION <push> */
		goto start; /* DEFAULT */
	}
}

/* MAIN PASS ANALYSER for pattern_regex */
static int
lexi_read_token_pattern_regex(struct lexi_state *state)
{
	start: {
		int c0 = lexi_readchar(state);
		if (c0 == '/') {
			/* ACTION <push> */
			{

	push(state->lex_state, c0);
			}
			/* END ACTION <push> */
			/* ACTION <flags> */
			{

	/* TODO: read g, i or gi or ig, push to buffer */
			}
			/* END ACTION <flags> */
			return lex_pattern__regex;
		}

		/* DEFAULT */
		/* ACTION <push> */
		{

	push(state->lex_state, c0);
		}
		/* END ACTION <push> */
		goto start; /* DEFAULT */
	}
}

/* MAIN PASS ANALYSER for pattern_string */
static int
lexi_read_token_pattern_string(struct lexi_state *state)
{
	start: {
		int c0 = lexi_readchar(state);
		switch (c0) {
		case '\\': {
				int c1 = lexi_readchar(state);
				switch (c1) {
				case 'r': {
						/* ACTION <push_esc> */
						{

	switch (c1) {
	case 'n': c1 = '\n'; break;
	case 'r': c1 = '\r'; break;
	case 't': c1 = '\t'; break;
	default:  assert(!"unreached");
	}

	push(state->lex_state, c1);
						}
						/* END ACTION <push_esc> */
						goto start;	/* leaf */
					}

				case 't': {
						/* ACTION <push_esc> */
						{

	switch (c1) {
	case 'n': c1 = '\n'; break;
	case 'r': c1 = '\r'; break;
	case 't': c1 = '\t'; break;
	default:  assert(!"unreached");
	}

	push(state->lex_state, c1);
						}
						/* END ACTION <push_esc> */
						goto start;	/* leaf */
					}

				case 'n': {
						/* ACTION <push_esc> */
						{

	switch (c1) {
	case 'n': c1 = '\n'; break;
	case 'r': c1 = '\r'; break;
	case 't': c1 = '\t'; break;
	default:  assert(!"unreached");
	}

	push(state->lex_state, c1);
						}
						/* END ACTION <push_esc> */
						goto start;	/* leaf */
					}

				}
				lexi_push(state, c1);
			}
			break;

		case '"': {
				return lex_pattern__literal;
			}

		}

		/* DEFAULT */
		/* ACTION <push> */
		{

	push(state->lex_state, c0);
		}
		/* END ACTION <push> */
		goto start; /* DEFAULT */
	}
}

/* MAIN PASS ANALYSER for pattern_literal */
static int
lexi_read_token_pattern_literal(struct lexi_state *state)
{
	start: {
		int c0 = lexi_readchar(state);
		if (c0 == '\'') {
			return lex_pattern__literal;
		}

		/* DEFAULT */
		/* ACTION <push> */
		{

	push(state->lex_state, c0);
		}
		/* END ACTION <push> */
		goto start; /* DEFAULT */
	}
}

/* MAIN PASS ANALYSER for comment */
static void
lexi_read_token_comment(struct lexi_state *state)
{
	start: {
		int c0 = lexi_readchar(state);
		if (c0 == '\n') {
			return;
		}

		/* DEFAULT */
		goto start; /* DEFAULT */
	}
}

/* MAIN PASS ANALYSER for the global zone */
int
lexi_read_token(struct lexi_state *state)
{
	if (state->zone != lexi_read_token)
		return state->zone(state);
	start: {
		int c0 = lexi_readchar(state);
		if (lexi_group(lexi_group_white, c0)) goto start;
		switch (c0) {
		case '$': {
				int c1 = lexi_readchar(state);
				if (lexi_group(lexi_group_alpha, c1)) {
					/* ACTION <flush> */
					{

	state->lex_state->tokbuf[0] = '\0';
					}
					/* END ACTION <flush> */
					/* ACTION <push> */
					{

	push(state->lex_state, c1);
					}
					/* END ACTION <push> */
					return lexi_read_token_token(state);
				}
				lexi_push(state, c1);
			}
			break;

		case '}': {
				return lex_close;
			}

		case '{': {
				return lex_open;
			}

		case LEXI_EOF: {
				return lex_eof;
			}

		case '-': {
				int c1 = lexi_readchar(state);
				if (c1 == '>') {
					return lex_map;
				}
				lexi_push(state, c1);
			}
			break;

		case '.': {
				int c1 = lexi_readchar(state);
				if (c1 == '.') {
					return lex_to;
				}
				lexi_push(state, c1);
			}
			break;

		case ';': {
				return lex_semi;
			}

		case '|': {
				return lex_alt;
			}

		case '/': {
				/* ACTION <flush> */
				{

	state->lex_state->tokbuf[0] = '\0';
				}
				/* END ACTION <flush> */
				/* ACTION <push> */
				{

	push(state->lex_state, c0);
				}
				/* END ACTION <push> */
				return lexi_read_token_pattern_regex(state);
			}

		case '"': {
				/* ACTION <flush> */
				{

	state->lex_state->tokbuf[0] = '\0';
				}
				/* END ACTION <flush> */
				return lexi_read_token_pattern_string(state);
			}

		case '\'': {
				/* ACTION <flush> */
				{

	state->lex_state->tokbuf[0] = '\0';
				}
				/* END ACTION <flush> */
				return lexi_read_token_pattern_literal(state);
			}

		case '#': {
				lexi_read_token_comment(state);
				goto start;	/* pure function */
			}

		}

		/* DEFAULT */
		return lexi_unknown_token;
	}
}


	struct lex_state *lex_init(FILE *f) {
		struct lex_state *new;

		assert(f != NULL);

		new = malloc(sizeof *new);
		if (new == NULL) {
			return NULL;
		}

		new->file = f;

		lexi_init(&new->lexi_state, new);

		return new;
	}

	int lex_nexttoken(struct lex_state *state) {
		assert(state != NULL);

		return lexi_read_token(&state->lexi_state);
	}

	void lex_free(struct lex_state *state) {
		assert(state != NULL);

		free(state);
	}

	const char *lex_tokbuf(struct lex_state *state) {
		assert(state != NULL);

		return state->tokbuf;
	}


