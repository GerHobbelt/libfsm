/* $Id$ */

%types%

	string;
	state;

%terminals%

	ident: () -> (:string);
	label: () -> (:string);
	any;

	start;
	end;

	arrow;

	sep;
	comma;
	equals;

	eof;
	!unknown;

%productions%

	<add-state>:        (:string) -> (:state);
	<mark-start>:       (:state)  -> ();
	<mark-end>:         (:state)  -> ();

	<free>:             (:string) -> ();
	<free-statelist>;

	<mark-colour>:      (:state, :string) -> ();

	<add-edge-literal>: (:state, :state, :string) -> ();
	<add-edge-any>:     (:state, :state)          -> ();
	<add-edge-epsilon>: (:state, :state)          -> ();

	<err-expected-sep>;
	<err-expected-trans>;
	<err-expected-comma>;
	<err-expected-equals>;
	<err-expected-start>;
	<err-expected-end>;
	<err-parse>;


	id: () -> (n :string) = {
		n = ident;
	||
		n = label;
	};

	ids = {
		n = id;
		s = <add-state>(n);
		<mark-end>(s);
	||
		ids;
		{
			comma;
		##
			<err-expected-comma>;
		};
		n = id;
		s = <add-state>(n);
		<mark-end>(s);
	};

	xend = {
		{
			end;
		##
			<err-expected-end>;
		};

		ids;

		{
			sep;
		##
			<err-expected-sep>;
		};
	};

	xstart: () -> (n :string) = {
		{
			start;
		##
			<err-expected-start>;
		};

		n = id;

		{
			sep;
		##
			<err-expected-sep>;
		};
	};

	edge = {
		a = id;
		arrow;
		b = id;

		x = <add-state>(a);
		y = <add-state>(b);

		{
			s = label;
			<add-edge-literal>(x, y, s);
			<free>(s);
		||
			any;
			<add-edge-any>(x, y);
		||
			<add-edge-epsilon>(x, y);
		##
			<err-expected-trans>;
		};

		{
			sep;
		##
			<err-expected-sep>;
		};
	};

	colour = {
		n = id;
		s = <add-state>(n);

		{
			equals;
		##
			<err-expected-equals>;
		};

		o = label;

		{
			sep;
		##
			<err-expected-sep>;
		};

		<mark-colour>(s, o);
	};

	things [

		thing = {
			edge;
		||
			colour;
		};

	] = {
		things;
		thing;
	||
		thing;
	};

	fsm = {
		{
			things;

			n = xstart;
			s = <add-state>(n);
			<mark-start>(s);
		||
			$;
		};

		{
			xend;
		||
			$;
		};

		eof;

		<free-statelist>;
	##
		<err-parse>;
	};

%entry%

	fsm;

