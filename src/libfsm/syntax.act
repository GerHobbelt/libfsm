/* $Id$ */

%prefixes%

	terminal = lex_;
	function = p_;

%maps%

	string -> string;
	int -> usint;
	state-list -> state_list;
	state -> state;

%header% @{

	#include <stdlib.h>
	#include <stdio.h>
	#include <stdlib.h>
	#include <string.h>

	#include <fsm/fsm.h>

	#include "cli/xmalloc.h"	/* XXX */
	#include "lexer.h"
	#include "syntax.h"

	typedef unsigned int usint;
	typedef const char * string;

	int lex_tok;
	int lex_tok_save;

	struct state_list *sl;
	struct label_list *ll;

	#define CURRENT_TERMINAL lex_tok
	#define ERROR_TERMINAL   lex_unknown
	#define ADVANCE_LEXER    do { lex_tok = lex_nexttoken();             } while (0);
	#define SAVE_LEXER(tok)  do { lex_tok_save = lex_tok; lex_tok = tok; } while (0);
	#define RESTORE_LEXER    do { lex_tok = lex_tok_save;                } while (0);

	static void err_expected(const char *token) {
		fprintf(stderr, "syntax error: expected %s\n", token);
		exit(EXIT_FAILURE);
	}

@}, @{

	#include <stdio.h>

	#include <fsm/fsm.h>

	typedef struct state_list * state_list;
	typedef struct fsm_state * state;

	void parse(FILE *f, struct state_list **s, struct label_list **l,
		struct fsm_state **start);

@};

%terminals%

	id: () -> (i :int) = @{
		@i = atoi(lex_tokbuf);
	@};

	label: () -> (s :string) = @{
		@s = xstrdup(lex_tokbuf);
	@};

%actions%

	<add-state>: (n :int) -> (s :state) = @{
		struct state_list *p;

		/* Find an existing state */
		for (p = sl; p; p = p->next) {
			if (p->state.id == @n) {
				break;
			}
		}

		/* Otherwise, create a new one */
		if (p == NULL) {
			p = xmalloc(sizeof *p);
			p->state.id = @n;
			p->state.edges = NULL;
			p->next = sl;
			sl = p;
		}

		@s = &p->state;
	@};

	<mark-end>: (n :int) -> () = @{
		struct state_list *p;

		for (p = sl; p; p = p->next) {
			if (p->state.id == @n) {
				p->state.end = 1;
				break;
			}
		}

		if (p == NULL) {
			fprintf(stderr, "unrecognised end state: %u\n", @n);
			@!;
		}
	@};

	<add-edge>: (x :state, y :state, c :string) -> () = @{
		struct label_list *p;
		struct fsm_edge   *e;

		/* Find an existing label */
		for (p = ll; p; p = p->next) {
			if (@c == NULL && p->label == NULL) {
				break;
			}

			if (@c == NULL || p->label == NULL) {
				continue;
			}

			if (0 == strcmp(p->label, @c)) {
				break;
			}
		}

		/* Otherwise, create a new one */
		if (p == NULL) {
			p = xmalloc(sizeof *p);
			p->label = @c;
			p->next = ll;
			ll = p;
		}

		e = xmalloc(sizeof *e);
		e->label = p;
		e->state = @y;
		e->next  = @x->edges;
		@x->edges = e;
	@};

	<find-start-state>: (n :int) -> (s :state) = @{
		struct state_list *p;

		/* TODO: move into API as find_state_by_id() or somesuch */
		@s = NULL;
		for (p = sl; p; p = p->next) {
			if (p->state.id == @n) {
				@s = &p->state;
			}
		}

		if (@s == NULL) {
			fprintf(stderr, "unrecognised start state %u\n", @n);
			@!;
		}
	@};

	<epsilon>: () -> (s :string) = @{
		@s = NULL;
	@};


	<err-syntax>: () -> (l :state-list, s :state) = @{
		(void) @l;
		(void) @s;

		fprintf(stderr, "syntax error\n");
		exit(EXIT_FAILURE);
	@};

	<err-expected-sep>: () -> () = @{
		err_expected("';'");
	@};

	<err-expected-comma>: () -> () = @{
		err_expected("','");
	@};

	<err-expected-start>: () -> () = @{
		err_expected("'start:'");
	@};

	<err-expected-end>: () -> () = @{
		err_expected("'end:'");
	@};

%trailer% @{

	void parse(FILE *f, struct state_list **s, struct label_list **l,
		struct fsm_state **start) {
		lex_init(f);
		ADVANCE_LEXER;
		p_fsm(start);
		*s = sl;
		*l = ll;
	}

@}, @{
@};

