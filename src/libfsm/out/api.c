/*
 * Copyright 2008-2017 Katherine Flavel
 *
 * See LICENCE for the full copyright terms.
 */

#include <ctype.h>
#include <assert.h>
#include <limits.h>
#include <stdio.h>

#include <adt/set.h>
#include <adt/bitmap.h>

#include <fsm/fsm.h>
#include <fsm/pred.h>
#include <fsm/walk.h>
#include <fsm/out.h>
#include <fsm/options.h>

#include "libfsm/internal.h"

#include "libfsm/out.h"

static unsigned int
indexof(const struct fsm *fsm, const struct fsm_state *state)
{
	struct fsm_state *s;
	unsigned int i;

	assert(fsm != NULL);
	assert(state != NULL);

	for (s = fsm->sl, i = 0; s != NULL; s = s->next, i++) {
		if (s == state) {
			return i;
		}
	}

	assert(!"unreached");
	return 0;
}

static int
escputc(int c, FILE *f)
{
	size_t i;

	const struct {
		int c;
		const char *s;
	} a[] = {
		{ '\\', "\\\\" },
		{ '\"', "\\\"" },
		{ '\'', "\\\'" },

		{ '\f', "\\f"  },
		{ '\n', "\\n"  },
		{ '\r', "\\r"  },
		{ '\t', "\\t"  },
		{ '\v', "\\v"  }
	};

	assert(c != FSM_EDGE_EPSILON);
	assert(f != NULL);

	for (i = 0; i < sizeof a / sizeof *a; i++) {
		if (a[i].c == c) {
			return fputs(a[i].s, f);
		}
	}

	if (!isprint((unsigned char) c)) {
		return fprintf(f, "\\%03o", (unsigned char) c);
	}

	return fprintf(f, "%c", c);
}

/* TODO: centralise */
static const struct fsm_state *
findany(const struct fsm_state *state)
{
	struct fsm_state *f, *s;
	struct fsm_edge *e;
	struct set_iter it;
	struct bm bm = { 0 };

	assert(state != NULL);

	e = set_first(state->edges, &it);
	if (e == NULL) {
		return NULL;
	}

	/* if the first edge is not the first character,
	 * then we can't possibly have an "any" transition */
	if (e->symbol != '\0') {
		return NULL;
	}

	f = set_first(e->sl, &it);
	if (f == NULL) {
		return NULL;
	}

	for (e = set_first(state->edges, &it); e != NULL; e = set_next(&it)) {
		if (e->symbol > UCHAR_MAX) {
			return NULL;
		}

		if (set_empty(e->sl)) {
			return NULL;
		}

		s = set_only(e->sl);
		if (f != s) {
			return NULL;
		}

		bm_set(&bm, e->symbol);
	}

	if (bm_count(&bm) != UCHAR_MAX + 1U) {
		return NULL;
	}

	assert(f != NULL);

	return f;
}

void
fsm_out_api(const struct fsm *fsm, FILE *f)
{
	struct fsm_state *s, *start;
	unsigned n;

	assert(fsm != NULL);
	assert(fsm->opt != NULL);
	assert(f != NULL);

/* TODO: leaf callback for opaques */

	if (fsm->opt->fragment) {
		fprintf(f, "\t");
	}
	fprintf(f, "/* Generated by libfsm */\n");
	fprintf(f, "\n");

	if (!fsm->opt->fragment) {
		fprintf(f, "#include LF_HEADER\n");
		fprintf(f, "\n");

		fprintf(f, "#include <stddef.h>\n");
		fprintf(f, "\n");

		fprintf(f, "#include <fsm/fsm.h>\n");
		fprintf(f, "\n");

		fprintf(f, "struct fsm *\n");
		fprintf(f, "%sfsm(const struct fsm_options *opt)\n",
			fsm->opt->prefix != NULL ? fsm->opt->prefix : "");

		fprintf(f, "{\n");
	}

	fprintf(f, "\tstruct fsm *fsm;\n");
	fprintf(f, "\tsize_t i;\n");
	fprintf(f, "\n");

	n = fsm_count(fsm, fsm_isany);
	fprintf(f, "\tstruct fsm_state *s[%u] = { 0 };\n", n);
	fprintf(f, "\n");

	fprintf(f, "\tfsm = fsm_new(opt);\n");
	fprintf(f, "\tif (fsm == NULL) {\n");
	fprintf(f, "\t\treturn NULL;\n");
	fprintf(f, "\t}\n");
	fprintf(f, "\n");

	fprintf(f, "\tfor (i = 0; i < %u; i++) {\n", n);
	fprintf(f, "\t\ts[i] = fsm_addstate(fsm);\n");
	fprintf(f, "\t\tif (s[i] == NULL) {\n");
	fprintf(f, "\t\t\tgoto error;\n");
	fprintf(f, "\t\t}\n");
	fprintf(f, "\t}\n");
	fprintf(f, "\n");

	for (s = fsm->sl; s != NULL; s = s->next) {
		struct fsm_edge *e;
		struct set_iter it;

		{
			const struct fsm_state *a;

			a = findany(s);
			if (a != NULL) {
				fprintf(f, "\tfsm_addedge_any(fsm, s[%u], s[%u]);\n",
					indexof(fsm, s), indexof(fsm, a));
				continue;
			}
		}

		for (e = set_first(s->edges, &it); e != NULL; e = set_next(&it)) {
			struct fsm_state *st;
			struct set_iter jt;

			for (st = set_first(e->sl, &jt); st != NULL; st = set_next(&jt)) {
				assert(st != NULL);

				switch (e->symbol) {
				case FSM_EDGE_EPSILON:
					fprintf(f, "\tif (!fsm_addedge_epsilon(fsm, s[%u], s[%u])) { goto error; {\n",
						indexof(fsm, s), indexof(fsm, st));
					break;

				default:
					fprintf(f, "\tif (!fsm_addedge_literal(fsm, s[%u], s[%u], '",
						indexof(fsm, s), indexof(fsm, st));
					escputc(e->symbol, f);
					fprintf(f, "')) { goto error; }\n");
					break;
				}
			}
		}
	}

	fprintf(f, "\n");

	start = fsm_getstart(fsm);
	if (start == NULL) {
		return;
	}

	fprintf(f, "\tfsm_setstart(fsm, s[%u]);\n", indexof(fsm, start));

	for (s = fsm->sl; s != NULL; s = s->next) {
		if (fsm_isend(fsm, s)) {
			fprintf(f, "\tfsm_setend(fsm, s[%u], 1);\n", indexof(fsm, s));
		}
	}

	if (!fsm->opt->fragment) {
		fprintf(f, "\n");
		fprintf(f, "\treturn fsm;\n");

		fprintf(f, "\n");
		fprintf(f, "error:\n");
		fprintf(f, "\n");
		fprintf(f, "\tfsm_free(fsm);\n");
		fprintf(f, "\n");
		fprintf(f, "\treturn NULL;\n");

		fprintf(f, "}\n");
		fprintf(f, "\n");
	}
}

