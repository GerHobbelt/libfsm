/* $Id$ */

%types%

	string;
	fsm;
	zone;
	ast;

%terminals%

	pattern_regex:   () -> (:string);
	pattern_literal: () -> (:string);

	map;
	to;
	semi;
	!alt;
	token_name: () -> (:string);

	open;
	close;

	!unknown;
	eof;

%productions%

	<compile-literal>: (:string) -> (:fsm);
	<compile-regex>:   (:string) -> (:fsm);

	!<regex-empty>: () -> (:fsm); /* TODO: proper name for matching the empty string? */
	<regex-any>:    () -> (:fsm);

	!<op-complement>: (:fsm)       -> ();
	!<op-complete>:   (:fsm)       -> ();
	!<op-subtract>:   (:fsm, :fsm) -> (:fsm);
	<op-concat>:      (:fsm, :fsm) -> (:fsm);

	<subtract-exit>:  (:fsm, :fsm) -> (:fsm);

	<make-ast>:     ()                                  -> (:ast);
	<make-zone>:    (:ast)                              -> (:zone);
	<make-mapping>: (:ast, :zone, :zone, :fsm, :string) -> ();

	<set-globalzone>: (:ast, :zone) -> ();

	<no-token>: () -> (:string);
	<no-exit>:  () -> (:fsm);
	<no-to>:    () -> (:zone);	/* TODO: rename target? */

	<clone>: (:fsm) -> (:fsm);
	!<free>: (:string) -> ();

	<err-syntax>;
	!<err-expected-alt>;
	<err-expected-map>;
	<err-expected-semi>;
	<err-expected-to>;
	<err-expected-open>;
	<err-expected-close>;
	<err-expected-eof>;

	<err-expected-list>;

	token-mapping: () -> (r :fsm, t :string) [

		pattern: () -> (r :fsm) = {
			s = pattern_literal;
			r = <compile-literal>(s);
		||
			s = pattern_regex;
			r = <compile-regex>(s);
		};

		concaternated-patterns: () -> (q :fsm) = {
			q = pattern;
		||
			a = concaternated-patterns;
			b = pattern;
			q = <op-concat>(a, b);
		};

	] = {
		r = concaternated-patterns;

		{
			t = <no-token>;
		||
			{
				map;
			##
				<err-expected-map>;
			};

			t = token_name;
		};
	};

	list-of-things: (a :ast, z :zone, exit :fsm) -> () [

		token-thing: (a :ast, z :zone, exit :fsm) -> (q :fsm, t :string) = {
			(r, t) = token-mapping;

			q = <subtract-exit>(r, exit);

			{
				semi;
			##
				<err-expected-semi>;
			};
		};

		zone-thing: (a :ast, parent :zone, exit :fsm) -> () = {
			(r1, t1) = token-mapping;

			q1 = <subtract-exit>(r1, exit);

			{
				to;
			##
				<err-expected-to>;
			};

			(r2, t2) = token-mapping;

			child = <make-zone>(a);

			{
				{
					semi;
				##
					<err-expected-semi>;
				};

				/*
				 * This is an implicit zone, written: /r1/ .. /r2/;
				 * which is equivalent to: /r1/ .. /r2/ { /./ - /r2/; }
				 * (i.e. discard everything which is not the exiting pattern.)
				 *
				 * If you want a zone where every character (other than the
				 * r2ing pattern) is treated as an error, then explicitly
				 * specify an empty zone instead: /r1/ .. /r2/ { }
				 */

				x = <no-to>;
				y = <no-token>;

				/*
				 * The exit pattern takes precedence over the zone body because
				 * it matches the shortest expression, rather than the usual
				 * greedy matching (which could traverse out of its accept state).
				 *
				 * This is easier to see visually; there are no transitions out
				 * of the exit pattern's accepting states because the result of
				 * subtraction is trimmed of dead states.
				 */

				u = <clone>(r2);
				w = <regex-any>;
				v = <subtract-exit>(w, u);

				<make-mapping>(a, child, x, v, y);
			||
				{
					open;
				##
					<err-expected-open>;
				};

				list-of-things(a, child, r2);

				{
					close;
				##
					<err-expected-close>;
				};
			##
				<err-expected-list>;
			};

			<make-mapping>(a, parent, child, q1, t1);
			<make-mapping>(a, child, parent, r2, t2);
		};

		/*
		 * All "things" within a zone have the parent zone's exit pattern
		 * subtracted from them (for an inner zone, the entry pattern
		 * has its parent's exit pattern subtracted).
		 *
		 * This is done just for user convenience; given that matching the
		 * exit pattern within a zone is illegal anyway (due to conflict),
		 * it is reasonable to write (for example) /./ and have the exit
		 * pattern excluded from that.
		 */

		thing: (a :ast, z :zone, exit :fsm) -> () = {
			(r, t) = token-thing(a, z, exit);
			to = <no-to>;
			<make-mapping>(a, z, to, r, t);
		||
			zone-thing(a, z, exit);
		};

	] = {
		thing(a, z, exit);
	||
		list-of-things(a, z, exit);
		thing(a, z, exit);
	##
		<err-expected-list>;
	};

	lx: () -> (a :ast) = {
		a = <make-ast>;
		z = <make-zone>(a);

		exit = <no-exit>;

		<set-globalzone>(a, z);

		list-of-things(a, z, exit);

		{
			eof;
		##
			<err-expected-eof>;
		};
	##
		a = <make-ast>;

		<err-syntax>;
	};

%entry%

	lx;

