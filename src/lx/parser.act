/* $Id$ */

%prefixes%

	terminal = TOK_;
	function = p_;

%persistents%

	lex_state :lex_state;
	act_state :act_state;

%maps%

	char   -> char;
	flags  -> flags;
	string -> string;
	fsm    -> fsm;
	zone   -> zone;
	ast    -> ast;

%header% @{

	#include <assert.h>
	#include <stdlib.h>
	#include <stdio.h>
	#include <errno.h>

	#include <adt/xalloc.h>

	#include <fsm/fsm.h>
	#include <fsm/bool.h>
	#include <fsm/pred.h>
	#include <fsm/graph.h>

	#include <re/re.h>

	#include "libfsm/internal.h"

	#include "lexer.h"
	#include "parser.h"
	#include "ast.h"
	#include "var.h"

	typedef char *               string;
	typedef enum re_cflags       flags;
	typedef struct fsm *         fsm;
	typedef struct ast_zone *    zone;
	typedef struct ast_mapping * mapping;

	struct act_state {
		enum lx_token lex_tok;
		enum lx_token lex_tok_save;
	};

	struct lex_state {
		struct lx lx;
		struct lx_dynbuf buf;

		/* TODO: use lx's generated conveniences for the pattern buffer */
		char a[512];
		char *p;
	};

	#define CURRENT_TERMINAL (act_state->lex_tok)
	#define ERROR_TERMINAL   TOK_UNKNOWN
	#define ADVANCE_LEXER    do { act_state->lex_tok = lx_next(&lex_state->lx); } while (0)
	#define SAVE_LEXER(tok)  do { act_state->lex_tok_save = act_state->lex_tok; \
	                              act_state->lex_tok = tok;                     } while (0)
	#define RESTORE_LEXER    do { act_state->lex_tok = act_state->lex_tok_save; } while (0)

	static void err_expected(const char *token) {
		fprintf(stderr, "syntax error: expected %s\n", token);
		exit(EXIT_FAILURE);
	}

@}, @{

	#include <stdio.h>

	#include "ast.h"

	typedef struct lex_state * lex_state;
	typedef struct act_state * act_state;
	typedef struct ast *       ast;

	struct ast *lx_parse(FILE *f);

@};

%terminals%

	ESC: () -> (c :char) = @{
		assert(lex_state->buf.a[0] == '\\');
		assert(lex_state->buf.a[1] != '\0');
		assert(lex_state->buf.a[2] == '\0');

		switch (lex_state->buf.a[1]) {
		case 'n':  @c = '\n'; break;
		case 't':  @c = '\t'; break;
		case 'r':  @c = '\r'; break;
		case '\\': @c = '\\'; break;
		default:   @c = '\0'; break; /* TODO: handle error */
		}
	@};

	CHAR: () -> (c :char) = @{
		assert(lex_state->buf.a[0] != '\0');
		assert(lex_state->buf.a[1] == '\0');

		@c = lex_state->buf.a[0];
	@};

	TOKEN: () -> (s :string) = @{
		/* TODO: submatch addressing */
		@s = xstrdup(lex_state->buf.a + 1); /* +1 for '$' prefix */
		if (@s == NULL) {
			perror("xstrdup");
			exit(EXIT_FAILURE);
		}
	@};

	IDENT: () -> (s :string) = @{
		@s = xstrdup(lex_state->buf.a);
		if (@s == NULL) {
			perror("xstrdup");
			exit(EXIT_FAILURE);
		}
	@};

	REEND: () -> (f :flags) = @{
		assert(lex_state->buf.a[0] == '/');

		/* TODO: submatch addressing */
		if (-1 == re_cflags(lex_state->buf.a + 1, &@f)) { /* TODO: +1 for '/' prefix */
			fprintf(stderr, "Unrecognised regexp flags: %s\n", lex_state->buf.a + 1);
			/* TODO: raise parse error */
		}
	@};

%actions%

	<pattern-char>: (c :char) -> () = @{
		/* TODO */
		*lex_state->p++ = @c;
	@};

	<pattern-buffer>: () -> (s :string) = @{
		/* TODO */
		*lex_state->p++ = '\0';

		@s = lex_state->a;

		lex_state->p = lex_state->a;
	@};

	<deref-var>: (z :zone, s :string) -> (r :fsm) = @{
		assert(@s != NULL);

		/* TODO: walk zone tree to root */

		@r = var_find(@z->vl, @s);
		if (@r == NULL) {
			/* TODO: use *err */
			fprintf(stderr, "No such variable: %s\n", @s);
			@!;
		}

		@r = fsm_clone(@r);
		if (@r == NULL) {
			/* TODO: use *err */
			perror("fsm_clone");
			@!;
		}
	@};

	<compile-literal>: (s :string) -> (r :fsm) = @{
		assert(@s != NULL);

		/* TODO: handle error codes */
		@r = re_new_comp(RE_LITERAL, re_getc_str, &@s, 0, NULL);
		if (@r == NULL) {
			/* TODO: use *err */
			@!;
		}
	@};

	<compile-regex>: (s :string, f :flags) -> (r :fsm) = @{
		assert(@s != NULL);

		/* TODO: handle error codes */
		@r = re_new_comp(RE_SIMPLE, re_getc_str, &@s, @f, NULL);
		if (@r == NULL) {
			/* TODO: use *err */
			@!;
		}
	@};

	/* equivalent to <compile-literal>("") but with less machination */
	<regex-empty>: () -> (r :fsm) = @{
		@r = re_new_empty();
		if (@r == NULL) {
			perror("re_new_empty");
			@!;
		}

		fsm_setend(@r, fsm_getstart(@r), 1);
	@};

	/* equivalent to <compile-regex>(".") but with less machination */
	<regex-any>: () -> (r :fsm) = @{
		struct fsm_state *e;

		@r = re_new_empty();
		if (@r == NULL) {
			perror("re_new_empty");
			@!;
		}

		e = fsm_addstate(@r);
		if (e == NULL) {
			perror("fsm_addstate");
			@!;
		}

		if (!fsm_addedge_any(@r, fsm_getstart(@r), e)) {
			perror("fsm_addedge_any");
			@!;
		}

		fsm_setend(@r, e, 1);
	@};

	<make-ast>: () -> (a :ast) = @{
		@a = ast_new();
		if (@a == NULL) {
			perror("ast_new");
			@!;
		}
	@};

	<make-zone>: (a :ast) -> (z :zone) = @{
		assert(@a != NULL);

		@z = ast_addzone(@a);
		if (@z == NULL) {
			perror("ast_addzone");
			@!;
		}
	@};

	<add-mapping>: (a :ast, from :zone, to :zone, r :fsm, t :string) -> () = @{
		struct ast_token *t;
		struct ast_mapping *m;

		assert(@a != NULL);
		assert(@from != NULL);
		assert(@from != @to);
		assert(@r != NULL);

		if (@t != NULL) {
			t = ast_addtoken(@a, @t);
			if (t == NULL) {
				perror("ast_addtoken");
				@!;
			}
		} else {
			t = NULL;
		}

		m = ast_addmapping(@from, @r, t, @to);
		if (m == NULL) {
			perror("ast_addmapping");
			@!;
		}
	@};

	<add-binding>: (a :ast, z :zone, n :string, r :fsm) -> () = @{
		struct var *v;

		assert(@a != NULL);
		assert(@z != NULL);
		assert(@n != NULL);
		assert(@r != NULL);

		(void) @a;

		v = var_bind(&@z->vl, @n, @r);
		if (v == NULL) {
			perror("var_bind");
			@!;
		}
	@};

	<set-globalzone>: (a :ast, z :zone) -> () = @{
		assert(@a != NULL);
		assert(@z != NULL);

		@a->global = @z;
	@};

	<no-token>: () -> (s :string) = @{
		@s = NULL;
	@};

	<no-exit>: () -> (r :fsm) = @{
		@r = NULL;
	@};

	<no-to>: () -> (z :zone) = @{
		@z = NULL;
	@};

	<op-complement>: (r :fsm) -> () = @{
		assert(@r != NULL);

		if (!fsm_complement(@r)) {
			perror("fsm_complement");
			@!;
		}
	@};

	<op-complete>: (r :fsm) -> () = @{
		assert(@r != NULL);

		if (!fsm_complete(@r)) {
			perror("fsm_complete");
			@!;
		}
	@};

	<op-subtract>: (a :fsm, b :fsm) -> (q :fsm) = @{
		assert(@a != NULL);
		assert(@b != NULL);

		@q = fsm_subtract(@a, @b);
		if (@q == NULL) {
			perror("fsm_subtract");
			@!;
		}
	@};

	<op-concat>: (a :fsm, b :fsm) -> (q :fsm) = @{
		assert(@a != NULL);
		assert(@b != NULL);

		@q = fsm_concat(@a, @b);
		if (@q == NULL) {
			perror("fsm_concat");
			@!;
		}
	@};

	<subtract-exit>: (a :fsm, b :fsm) -> (q :fsm) = @{
		assert(@a != NULL);

		if (@b == NULL) {
			@q = @a;
		} else {
			@b = fsm_clone(@b);
			if (@b == NULL) {
				perror("fsm_clone");
				@!;
			}

			@q = fsm_subtract(@a, @b);
			if (@q == NULL) {
				perror("fsm_subtract");
				@!;
			}

			if (!fsm_trim(@q)) {
				perror("fsm_trim");
				@!;
			}
		}
	@};

	<clone>: (r :fsm) -> (q :fsm) = @{
		assert(@r != NULL);

		@q = fsm_clone(@r);
		if (@q == NULL) {
			perror("fsm_clone");
			@!;
		}
	@};

	<free>: (s :string) -> () = @{
		free(@s);
	@};

	<err-syntax> = @{
		fprintf(stderr, "syntax error\n");
		exit(EXIT_FAILURE);
	@};

	<err-expected-alt> = @{
		err_expected("'|'");
	@};

	<err-expected-map> = @{
		err_expected("'->'");
	@};

	<err-expected-bind> = @{
		err_expected("'='");
	@};

	<err-expected-semi> = @{
		err_expected("';'");
	@};

	<err-expected-to> = @{
		err_expected("'..'");
	@};

	<err-expected-open> = @{
		err_expected("'{'");
	@};

	<err-expected-close> = @{
		err_expected("'}'");
	@};

	<err-expected-eof> = @{
		err_expected("EOF");
	@};

	<err-expected-list> = @{
		err_expected("list of token mappings or zones");
	@};

%trailer% @{

	struct ast *lx_parse(FILE *f) {
		struct act_state act_state_s;
		struct act_state *act_state;
		struct lex_state lex_state_s;
		struct lex_state *lex_state;
		struct ast *ast;
		struct lx *lx;

		assert(f != NULL);

		lex_state = &lex_state_s;

		lex_state->p = lex_state->a;

		lx = &lex_state->lx;

		lx_init(lx);

		lx->lgetc  = lx_fgetc;
		lx->opaque = f;

		lex_state->buf.a   = NULL;
		lex_state->buf.len = 0;

		lx->buf   = &lex_state->buf;
		lx->push  = lx_dynpush;
		lx->pop   = lx_dynpop;
		lx->clear = lx_dynclear;
		lx->free  = lx_dynfree;

		/* This is a workaround for ADVANCE_LEXER assuming a pointer */
		act_state = &act_state_s;

		ADVANCE_LEXER;	/* XXX: what if the first token is unrecognised? */
		p_lx(lex_state, act_state, &ast);

		assert(ast != NULL);

		return ast;
	}

@}, @{

@};

