/* $Id$ */

%prefixes%

	terminal = lex_;
	function = p_;

%persistents%

	lex_state :lex_state;
	act_state :act_state;

%maps%

	string -> string;
	fsm    -> fsm;
	zone   -> zone;
	ast    -> ast;

%header% @{

	#include <assert.h>
	#include <stdlib.h>
	#include <stdio.h>
	#include <errno.h>

	#include <adt/xalloc.h>

	#include <fsm/fsm.h>
	#include <fsm/bool.h>
	#include <fsm/graph.h>

	#include <re/re.h>

	#include "libfsm/internal.h"

	#include "lexer.h"
	#include "parser.h"
	#include "ast.h"

	typedef char *               string;
	typedef struct fsm *         fsm;
	typedef struct ast_zone *    zone;
	typedef struct ast_mapping * mapping;

	struct act_state {
		int lex_tok;
		int lex_tok_save;
	};

	#define CURRENT_TERMINAL (act_state->lex_tok)
	#define ERROR_TERMINAL   lex_unknown
	#define ADVANCE_LEXER    do { act_state->lex_tok = lex_nexttoken(lex_state); } while (0)
	#define SAVE_LEXER(tok)  do { act_state->lex_tok_save = act_state->lex_tok; \
	                              act_state->lex_tok = tok;                      } while (0)
	#define RESTORE_LEXER    do { act_state->lex_tok = act_state->lex_tok_save;  } while (0)

	static void err_expected(const char *token) {
		fprintf(stderr, "syntax error: expected %s\n", token);
		exit(EXIT_FAILURE);
	}

	static int notend(const struct fsm *fsm, const struct fsm_state *state) {
		return !fsm_isend(fsm, state);
	}

	static int trapstate(const struct fsm *fsm, const struct fsm_state *state) {
		if (state == fsm_getstart(fsm)) {
			return 0;
		}

		if (fsm_isend(fsm, state)) {
			return 0;
		}

		return 1;
	}

@}, @{

	#include <stdio.h>

	#include "ast.h"

	typedef struct lex_state * lex_state;
	typedef struct act_state * act_state;
	typedef struct ast *       ast;

	struct ast *lx_parse(FILE *f);

@};

%terminals%

	pattern_regex: () -> (s :string) = @{
		@s = xstrdup(lex_tokbuf(lex_state));
		if (@s == NULL) {
			perror("xstrdup");
			exit(EXIT_FAILURE);
		}
	@};

	pattern_literal: () -> (s :string) = @{
		@s = xstrdup(lex_tokbuf(lex_state));
		if (@s == NULL) {
			perror("xstrdup");
			exit(EXIT_FAILURE);
		}
	@};

	token_name: () -> (s :string) = @{
		@s = xstrdup(lex_tokbuf(lex_state));
		if (@s == NULL) {
			perror("xstrdup");
			exit(EXIT_FAILURE);
		}
	@};

%actions%

	<compile-literal>: (s :string) -> (r :fsm) = @{
		assert(@s != NULL);

		/* TODO: handle error codes */
		@r = re_new_comp(RE_LITERAL, re_getc_str, &@s, 0, NULL);
		if (@r == NULL) {
			/* TODO: use *err */
			@!;
		}
	@};

	<compile-regex>:   (s :string) -> (r :fsm) = @{
		assert(@s != NULL);

		/* TODO: handle error codes */
		@r = re_new_comp(RE_SIMPLE, re_getc_str, &@s, 0, NULL);
		if (@r == NULL) {
			/* TODO: use *err */
			@!;
		}
	@};

	<make-ast>: () -> (a :ast) = @{
		@a = ast_new();
		if (@a == NULL) {
			perror("ast_new");
			@!;
		}
	@};

	<make-zone>: (a :ast) -> (z :zone) = @{
		assert(@a != NULL);

		@z = ast_addzone(@a);
		if (@z == NULL) {
			perror("ast_addzone");
			@!;
		}
	@};

	<make-mapping>: (a :ast, from :zone, to :zone, r :fsm, t :string) -> () = @{
		struct ast_token *t;
		struct ast_mapping *m;

		assert(@a != NULL);
		assert(@from != NULL);
		assert(@from != @to);
		assert(@r != NULL);

		if (@t != NULL) {
			t = ast_addtoken(@a, @t);
			if (t == NULL) {
				perror("ast_addtoken");
				@!;
			}
		} else {
			t = NULL;
		}

		m = ast_addmapping(@from, @r, t, @to);
		if (m == NULL) {
			perror("ast_addmapping");
			@!;
		}
	@};

	<set-globalzone>: (a :ast, z :zone) -> () = @{
		assert(@a != NULL);
		assert(@z != NULL);

		@a->global = @z;
	@};

	<no-token>: () -> (s :string) = @{
		@s = NULL;
	@};

	<no-to>: () -> (z :zone) = @{
		@z = NULL;
	@};

	<trap>: (r :fsm) -> () = @{
		struct fsm_state *trap;
		struct fsm_state *s;

		if (!fsm_complete(@r, notend)) {
			perror("fsm_complete");
			@!;
		}

		trap = fsm_collate(@r, trapstate);
		if (trap == NULL && errno != 0) { /* XXX: hackish */
			if (trap == NULL) {
				perror("fsm_collate");
				@!;
			}
		}

		for (s = @r->sl; s != NULL; s = s->next) {
			fsm_setend(@r, s, 0);
		}

		if (trap != NULL) {
			assert(trap != fsm_getstart(@r));

			fsm_setend(@r, trap, 1);

			/* TODO: must set opaque here, i think */
		}
	@};

	<op-concat>: (a :fsm, b :fsm) -> (q :fsm) = @{
		assert(@a != NULL);
		assert(@b != NULL);

		@q = fsm_concat(@a, @b);
		if (@q == NULL) {
			perror("fsm_concat");
			@!;
		}
	@};

	<clone>: (r :fsm) -> (q :fsm) = @{
		assert(@r != NULL);

		@q = fsm_clone(@r);
		if (@q == NULL) {
			perror("fsm_clone");
			@!;
		}
	@};

	<free>: (s :string) -> () = @{
		free(@s);
	@};

	<err-syntax> = @{
		fprintf(stderr, "syntax error\n");
		exit(EXIT_FAILURE);
	@};

	<err-expected-alt> = @{
		err_expected("'|'");
	@};

	<err-expected-map> = @{
		err_expected("'->'");
	@};

	<err-expected-semi> = @{
		err_expected("';'");
	@};

	<err-expected-to> = @{
		err_expected("'..'");
	@};

	<err-expected-open> = @{
		err_expected("'{'");
	@};

	<err-expected-close> = @{
		err_expected("'}'");
	@};

	<err-expected-eof> = @{
		err_expected("EOF");
	@};

	<err-expected-list> = @{
		err_expected("list of token mappings or zones");
	@};

%trailer% @{

	struct ast *lx_parse(FILE *f) {
		struct act_state act_state_s;
		struct act_state *act_state;
		struct lex_state *lex_state;
		struct ast *ast;

		assert(f != NULL);

		lex_state = lex_init(f);
		if (lex_state == NULL) {
			perror("lex_init");
			return NULL;
		}

		/* This is a workaround for ADVANCE_LEXER assuming a pointer */
		act_state = &act_state_s;

		ADVANCE_LEXER;	/* XXX: what if the first token is unrecognised? */
		p_lx(lex_state, act_state, &ast);

		assert(ast != NULL);

		lex_free(lex_state);

		return ast;
	}

@}, @{

@};

