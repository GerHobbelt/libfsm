/* $Id$ */

#include <assert.h>
#include <stdio.h>
#include <ctype.h>

#include "../ast.h"
#include "../internal.h"

#include "out.h"

/* TODO: centralise */
static void
out_esctok(FILE *f, const char *s)
{
	const char *p;

	assert(f != NULL);
	assert(s != NULL);

	for (p = s; *p != '\0'; p++) {
		fputc(isalnum(*p) ? toupper(*p) : '_', f);
	}
}

static void
out_tokens(const struct ast *ast, FILE *f)
{
	struct ast_token *t;

	assert(ast != NULL);
	assert(f != NULL);

	fprintf(f, "enum lx_token {\n");

	/* TODO: the token prefix needs to be configurable */
	for (t = ast->tl; t != NULL; t = t->next) {
		fprintf(f, "\tTOK_");
		out_esctok(f, t->s);
		fprintf(f, ",\n");
	}

	fprintf(f, "\tTOK_EOF,\n");
	fprintf(f, "\tTOK_ERROR,\n");
	fprintf(f, "\tTOK_UNKNOWN\n");

	fprintf(f, "};\n");
}

void
lx_out_h(const struct ast *ast, FILE *f)
{
	assert(ast != NULL);
	assert(f != NULL);

	fprintf(f, "/* Generated by lx */\n");	/* TODO: date, input etc */
	fprintf(f, "\n");

	/* TODO: this guard macro needs to be configurable */
	fprintf(f, "#ifndef LX_H\n");
	fprintf(f, "#define LX_H\n");
	fprintf(f, "\n");

	out_tokens(ast, f);
	fprintf(f, "\n");

	fprintf(f, "struct lx_pos {\n");
	fprintf(f, "\tunsigned byte;\n");
	fprintf(f, "\tunsigned line;\n");
	fprintf(f, "\tunsigned col;\n");
	fprintf(f, "};\n");
	fprintf(f, "\n");

	fprintf(f, "struct lx {\n");
	fprintf(f, "\tint (*lgetc)(struct lx *lx);\n");
	fprintf(f, "\tvoid *opaque;\n");
	fprintf(f, "\n");
	fprintf(f, "\tint c; /* %sungetc buffer */\n", prefix);
	fprintf(f, "\n");
	fprintf(f, "\tstruct lx_pos start;\n");
	fprintf(f, "\tstruct lx_pos end;\n");
	fprintf(f, "\n");
	fprintf(f, "\tvoid *buf;\n");
	fprintf(f, "\tint  (*push) (struct lx *lx, char c);\n");
	fprintf(f, "\tvoid (*pop)  (struct lx *lx);\n");
	fprintf(f, "\tint  (*clear)(struct lx *lx);\n");
	fprintf(f, "\tvoid (*free) (struct lx *lx);\n");
	fprintf(f, "\n");
	fprintf(f, "\tenum lx_token (*z)(struct lx *lx);\n");
	fprintf(f, "};\n");
	fprintf(f, "\n");

	fprintf(f, "/*\n");
	fprintf(f, " * The initial buffer size; this ought to be over the typical token length,\n");
	fprintf(f, " * so as to avoid a run-up of lots of resizing.\n");
	fprintf(f, " */\n");
	fprintf(f, "#ifndef LX_DYN_LOW\n");
	fprintf(f, "#define LX_DYN_LOW 1 << 10\n");
	fprintf(f, "#endif\n");
	fprintf(f, "\n");

	fprintf(f, "/*\n");
	fprintf(f, " * High watermark; if the buffer grows over this, it will resize back down\n");
	fprintf(f, " * by LX_DYN_FACTOR when no longer in use.\n");
	fprintf(f, " */\n");
	fprintf(f, "#ifndef LX_DYN_HIGH\n");
	fprintf(f, "#define LX_DYN_HIGH 1 << 13\n");
	fprintf(f, "#endif\n");
	fprintf(f, "\n");

	fprintf(f, "/*\n");
	fprintf(f, " * Andrew Koenig said the growth factor should be less than phi, (1 + sqrt(5)) / 2\n");
	fprintf(f, " * P.J. Plauger said 1.5 works well in practice. (Perhaps because of internal\n");
	fprintf(f, " * bookkeeping data stored by the allocator.)\n");
	fprintf(f, " *\n");
	fprintf(f, " * Non-integer factors here add the constraint that LX_DYN_LOW > 1 because\n");
	fprintf(f, " * because conversion to size_t truncates, and e.g. 1 * 1.5 == 1 is no good\n");
	fprintf(f, " * as the requirement is to *increase* a buffer.\n");
	fprintf(f, " */\n");
	fprintf(f, "#ifndef LX_DYN_FACTOR\n");
	fprintf(f, "#define LX_DYN_FACTOR 2\n");
	fprintf(f, "#endif\n");
	fprintf(f, "\n");

	fprintf(f, "/* dynamic token buffer */\n");
	fprintf(f, "struct lx_dynbuf {\n");
	fprintf(f, "\tchar *p;\n");
	fprintf(f, "\tsize_t len;\n");
	fprintf(f, "\tchar *a;\n");
	fprintf(f, "};\n");
	fprintf(f, "\n");

	fprintf(f, "/* fixed-size token buffer */\n");
	fprintf(f, "struct lx_fixedbuf {\n");
	fprintf(f, "\tchar *p;\n");
	fprintf(f, "\tsize_t len;\n");
	fprintf(f, "#ifdef LX_FIXED_SIZE\n");
	fprintf(f, "\tchar a[LX_FIXED_SIZE];\n");
	fprintf(f, "#else\n");
	fprintf(f, "\tchar *a; /* could be flexible member */\n");
	fprintf(f, "#endif\n");
	fprintf(f, "};\n");
	fprintf(f, "\n");

	fprintf(f, "/* opaque for %sagetc */\n", prefix);
	fprintf(f, "struct lx_arr {\n");
	fprintf(f, "\tchar *p;\n");
	fprintf(f, "\tsize_t len;\n");
	fprintf(f, "};\n");
	fprintf(f, "\n");

	/* TODO: posix only */
	fprintf(f, "/* opaque for %sfdgetc */\n", prefix);
	fprintf(f, "struct lx_fd {\n");
	fprintf(f, "\tchar *p;\n");
	fprintf(f, "\tsize_t len;\n");
	fprintf(f, "\n");
	fprintf(f, "\tint fd;\n");
	fprintf(f, "\tsize_t bufsz; /* number of bytes allocated after this struct */\n");
	fprintf(f, "};\n");
	fprintf(f, "\n");

	fprintf(f, "const char *%sname(enum lx_token t);\n", prefix);
	fprintf(f, "const char *%sexample(enum lx_token (*z)(struct lx *), enum lx_token t);\n", prefix);
	fprintf(f, "\n");

	fprintf(f, "void %sinit(struct lx *lx);\n", prefix);
	fprintf(f, "enum lx_token %snext(struct lx *lx);\n", prefix);
	fprintf(f, "\n");

	fprintf(f, "int %sfgetc(struct lx *lx);\n", prefix); /* TODO: stdio only */
	fprintf(f, "int %ssgetc(struct lx *lx);\n", prefix);
	fprintf(f, "int %sagetc(struct lx *lx);\n", prefix);
	fprintf(f, "int %sdgetc(struct lx *lx);\n", prefix);
	fprintf(f, "\n");

	fprintf(f, "int  %sdynpush(struct lx *lx, char c);\n", prefix);
	fprintf(f, "void %sdynpop(struct lx *lx);\n", prefix);
	fprintf(f, "int  %sdynclear(struct lx *lx);\n", prefix);
	fprintf(f, "void %sdynfree(struct lx *lx);\n", prefix);
	fprintf(f, "\n");

	fprintf(f, "int  %sfixedpush(struct lx *lx, char c);\n", prefix);
	fprintf(f, "void %sfixedpop(struct lx *lx);\n", prefix);
	fprintf(f, "int  %sfixedclear(struct lx *lx);\n", prefix);
	fprintf(f, "\n");

	fprintf(f, "#endif\n");
	fprintf(f, "\n");
}

